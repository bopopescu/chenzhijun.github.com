<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>饺子</title>
  
  <subtitle>优于别人，并不高贵，真正的高贵应该是优于过去的自己</subtitle>
  <link href="/rss.xml" rel="self"/>
  
  <link href="http://chenzhijun.me/"/>
  <updated>2020-05-13T13:33:03.891Z</updated>
  <id>http://chenzhijun.me/</id>
  
  <author>
    <name>陈志军</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Harbor  镜像仓库安装与 Helm Chart 管理</title>
    <link href="http://chenzhijun.me/2020/04/26/harbor-install-and-trouble-shooting/"/>
    <id>http://chenzhijun.me/2020/04/26/harbor-install-and-trouble-shooting/</id>
    <published>2020-04-26T13:02:35.000Z</published>
    <updated>2020-05-13T13:33:03.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Harbor-镜像仓库安装与-Helm-Chart-管理"><a href="#Harbor-镜像仓库安装与-Helm-Chart-管理" class="headerlink" title="Harbor  镜像仓库安装与 Helm Chart 管理"></a>Harbor  镜像仓库安装与 Helm Chart 管理</h1><p><a href="https://goharbor.io/" target="_blank" rel="noopener">Harbor</a> 是一款非常优秀的企业级开源镜像仓库管理器。Harbor 是基于 Docker Registry之上带有用户权限控制，镜像扫描，镜像签名的款工具。用起来很方便，我们公司目前在测试和生产都在使用。从去年 10 月到今天，除去一次 ceph 集群扩容，没有发生一次事故，一直运行很稳定；本文将记录一下我们的使用方式和遇到的一些问题解决方式。</p><h2 id="Harbor-资源准备"><a href="#Harbor-资源准备" class="headerlink" title="Harbor 资源准备"></a>Harbor 资源准备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Harbor 1.7.6 版本</span><br><span class="line">Redis 4.0</span><br><span class="line">Postgres 10.6</span><br><span class="line">Docker 1.13.1</span><br><span class="line">docker-compose 1.18.0</span><br><span class="line">Ceph 12</span><br><span class="line"></span><br><span class="line">haproxy 机器 2 台</span><br><span class="line">VIP 1 个</span><br><span class="line">Harbor 主机 2 台</span><br></pre></td></tr></table></figure><p>公司目前的 harbor 是基于 1.76 搭建的高可用方案，证书的问题，我们是公网使用第三方证书。内网使用自签名的证书；在我这里，我在 harbor 的搭建中采用的是内部 http，外部挂 F5。架构图如下：</p><p><img src="/images/qiniu/2020-04-26-21-15-43.png" alt="2020-04-26-21-15-43"></p><p>生产上我们用 F5 替代 Haproxy。</p><p>我们在 Haproxy/F5 层将 https 转成 http 再转发给内部 harbor。<br><a id="more"></a></p><h3 id="下载-harbor-并进行配置"><a href="#下载-harbor-并进行配置" class="headerlink" title="下载 harbor 并进行配置"></a>下载 harbor 并进行配置</h3><p>直接去github release 下载 1.7.6 的版本（现在最新为 1.10）。下载之后解压，修改里面<code>harbor.cfg</code>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">## Configuration file of Harbor</span><br><span class="line"></span><br><span class="line">#This attribute is for migrator to detect the version of the .cfg file, DO NOT MODIFY!</span><br><span class="line">_version = 1.7.0</span><br><span class="line">#The IP address or hostname to access admin UI and registry service.</span><br><span class="line">#DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.</span><br><span class="line">#DO NOT comment out this line, modify the value of &quot;hostname&quot; directly, or the installation will fail.</span><br><span class="line">hostname = harbor.chenzhijun.me</span><br><span class="line"></span><br><span class="line">#The protocol for accessing the UI and token/notification service, by default it is http.</span><br><span class="line">#It can be set to https if ssl is enabled on nginx.</span><br><span class="line">ui_url_protocol = http</span><br><span class="line"></span><br><span class="line">#Maximum number of job workers in job service</span><br><span class="line">max_job_workers = 10</span><br><span class="line"></span><br><span class="line">#Determine whether or not to generate certificate for the registry&apos;s token.</span><br><span class="line">#If the value is on, the prepare script creates new root cert and private key</span><br><span class="line">#for generating token to access the registry. If the value is off the default key/cert will be used.</span><br><span class="line">#This flag also controls the creation of the notary signer&apos;s cert.</span><br><span class="line">#这里我选择的是 off，开 notary 的话必须指定https，如果不开 notary 的话，可以不用管。</span><br><span class="line">customize_crt = off</span><br><span class="line"></span><br><span class="line">#The path of cert and key files for nginx, they are applied only the protocol is set to https</span><br><span class="line">ssl_cert = /data/cert/server.crt</span><br><span class="line">ssl_cert_key = /data/cert/server.key</span><br><span class="line"></span><br><span class="line">#The path of secretkey storage</span><br><span class="line">secretkey_path = /data</span><br><span class="line"></span><br><span class="line">#Admiral&apos;s url, comment this attribute, or set its value to NA when Harbor is standalone</span><br><span class="line">admiral_url = NA</span><br><span class="line"></span><br><span class="line">#Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated.</span><br><span class="line">log_rotate_count = 50</span><br><span class="line">#Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes.</span><br><span class="line">#If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G</span><br><span class="line">#are all valid.</span><br><span class="line">log_rotate_size = 200M</span><br><span class="line"></span><br><span class="line">#Config http proxy for Clair, e.g. http://my.proxy.com:3128</span><br><span class="line">#Clair doesn&apos;t need to connect to harbor internal components via http proxy.</span><br><span class="line">http_proxy =</span><br><span class="line">https_proxy =</span><br><span class="line">no_proxy = 127.0.0.1,localhost,core,registry</span><br><span class="line"></span><br><span class="line">#NOTES: The properties between BEGIN INITIAL PROPERTIES and END INITIAL PROPERTIES</span><br><span class="line">#only take effect in the first boot, the subsequent changes of these properties</span><br><span class="line">#should be performed on web ui</span><br><span class="line"></span><br><span class="line">#************************BEGIN INITIAL PROPERTIES************************</span><br><span class="line"></span><br><span class="line">#Email account settings for sending out password resetting emails.</span><br><span class="line"></span><br><span class="line">#Email server uses the given username and password to authenticate on TLS connections to host and act as identity.</span><br><span class="line">#Identity left blank to act as username.</span><br><span class="line">email_identity =</span><br><span class="line"></span><br><span class="line">email_server = smtp.mydomain.com</span><br><span class="line">email_server_port = 25</span><br><span class="line">email_username = sample_admin@mydomain.com</span><br><span class="line">email_password = abc</span><br><span class="line">email_from = admin &lt;sample_admin@mydomain.com&gt;</span><br><span class="line">email_ssl = false</span><br><span class="line">email_insecure = false</span><br><span class="line"></span><br><span class="line">##The initial password of Harbor admin, only works for the first time when Harbor starts.</span><br><span class="line">#It has no effect after the first launch of Harbor.</span><br><span class="line">#Change the admin password from UI after launching Harbor.</span><br><span class="line">harbor_admin_password = Harbor12345</span><br><span class="line"></span><br><span class="line">##By default the auth mode is db_auth, i.e. the credentials are stored in a local database.</span><br><span class="line">#Set it to ldap_auth if you want to verify a user&apos;s credentials against an LDAP server.</span><br><span class="line">auth_mode = db_auth</span><br><span class="line"></span><br><span class="line">#The url for an ldap endpoint.</span><br><span class="line">ldap_url = ldaps://ldap.mydomain.com</span><br><span class="line"></span><br><span class="line">#A user&apos;s DN who has the permission to search the LDAP/AD server.</span><br><span class="line">#If your LDAP/AD server does not support anonymous search, you should configure this DN and ldap_search_pwd.</span><br><span class="line">#ldap_searchdn = uid=searchuser,ou=people,dc=mydomain,dc=com</span><br><span class="line"></span><br><span class="line">#the password of the ldap_searchdn</span><br><span class="line">#ldap_search_pwd = password</span><br><span class="line"></span><br><span class="line">#The base DN from which to look up a user in LDAP/AD</span><br><span class="line">ldap_basedn = ou=people,dc=mydomain,dc=com</span><br><span class="line"></span><br><span class="line">#Search filter for LDAP/AD, make sure the syntax of the filter is correct.</span><br><span class="line">#ldap_filter = (objectClass=person)</span><br><span class="line"></span><br><span class="line"># The attribute used in a search to match a user, it could be uid, cn, email, sAMAccountName or other attributes depending on your LDAP/AD</span><br><span class="line">ldap_uid = uid</span><br><span class="line"></span><br><span class="line">#the scope to search for users, 0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE</span><br><span class="line">ldap_scope = 2</span><br><span class="line"></span><br><span class="line">#Timeout (in seconds)  when connecting to an LDAP Server. The default value (and most reasonable) is 5 seconds.</span><br><span class="line">ldap_timeout = 5</span><br><span class="line"></span><br><span class="line">#Verify certificate from LDAP server</span><br><span class="line">ldap_verify_cert = true</span><br><span class="line"></span><br><span class="line">#The base dn from which to lookup a group in LDAP/AD</span><br><span class="line">ldap_group_basedn = ou=group,dc=mydomain,dc=com</span><br><span class="line"></span><br><span class="line">#filter to search LDAP/AD group</span><br><span class="line">ldap_group_filter = objectclass=group</span><br><span class="line"></span><br><span class="line">#The attribute used to name a LDAP/AD group, it could be cn, name</span><br><span class="line">ldap_group_gid = cn</span><br><span class="line"></span><br><span class="line">#The scope to search for ldap groups. 0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE</span><br><span class="line">ldap_group_scope = 2</span><br><span class="line"></span><br><span class="line">#Turn on or off the self-registration feature</span><br><span class="line"># 是否允许自注册</span><br><span class="line">self_registration = on</span><br><span class="line"></span><br><span class="line">#The expiration time (in minute) of token created by token service, default is 30 minutes</span><br><span class="line">token_expiration = 30</span><br><span class="line"></span><br><span class="line">#The flag to control what users have permission to create projects</span><br><span class="line">#The default value &quot;everyone&quot; allows everyone to creates a project.</span><br><span class="line">#Set to &quot;adminonly&quot; so that only admin user can create project.</span><br><span class="line">project_creation_restriction = everyone</span><br><span class="line"></span><br><span class="line">#************************END INITIAL PROPERTIES************************</span><br><span class="line"></span><br><span class="line">#######Harbor DB configuration section#######</span><br><span class="line"></span><br><span class="line">#The address of the Harbor database. Only need to change when using external db.</span><br><span class="line">#db的主机</span><br><span class="line">db_host = 172.88.14.88</span><br><span class="line"></span><br><span class="line">#The password for the root user of Harbor DB. Change this before any production use.</span><br><span class="line">db_password = 123456</span><br><span class="line"></span><br><span class="line">#The port of Harbor database host</span><br><span class="line">db_port = 5432</span><br><span class="line"></span><br><span class="line">#The user name of Harbor database</span><br><span class="line">db_user = postgres</span><br><span class="line"></span><br><span class="line">##### End of Harbor DB configuration#######</span><br><span class="line"></span><br><span class="line">##########Redis server configuration.############</span><br><span class="line"></span><br><span class="line">#Redis connection address</span><br><span class="line">redis_host = 172.88.14.88</span><br><span class="line"></span><br><span class="line">#Redis connection port</span><br><span class="line">redis_port = 6379</span><br><span class="line"></span><br><span class="line">#Redis connection password</span><br><span class="line">redis_password =</span><br><span class="line"></span><br><span class="line">#Redis connection db index</span><br><span class="line">#db_index 1,2,3 is for registry, jobservice and chartmuseum.</span><br><span class="line">#db_index 0 is for UI, it&apos;s unchangeable</span><br><span class="line">redis_db_index = 1,2,3</span><br><span class="line"></span><br><span class="line">########## End of Redis server configuration ############</span><br><span class="line"></span><br><span class="line">##########Clair DB configuration############</span><br><span class="line"></span><br><span class="line">#Clair DB host address. Only change it when using an exteral DB.</span><br><span class="line"></span><br><span class="line">clair_db_host = 172.88.14.88</span><br><span class="line">#The password of the Clair&apos;s postgres database. Only effective when Harbor is deployed with Clair.</span><br><span class="line">#Please update it before deployment. Subsequent update will cause Clair&apos;s API server and Harbor unable to access Clair&apos;s database.</span><br><span class="line">clair_db_password = 123456</span><br><span class="line">#Clair DB connect port</span><br><span class="line">clair_db_port = 5432</span><br><span class="line">#Clair DB username</span><br><span class="line">clair_db_username = postgres</span><br><span class="line">#Clair default database</span><br><span class="line">clair_db = postgres</span><br><span class="line"></span><br><span class="line">#The interval of clair updaters, the unit is hour, set to 0 to disable the updaters.</span><br><span class="line">clair_updaters_interval = 12</span><br><span class="line"></span><br><span class="line">##########End of Clair DB configuration############</span><br><span class="line"></span><br><span class="line">#The following attributes only need to be set when auth mode is uaa_auth</span><br><span class="line">uaa_endpoint = uaa.mydomain.org</span><br><span class="line">uaa_clientid = id</span><br><span class="line">uaa_clientsecret = secret</span><br><span class="line">uaa_verify_cert = true</span><br><span class="line">uaa_ca_cert = /path/to/ca.pem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Harbor Storage settings ###</span><br><span class="line">#Please be aware that the following storage settings will be applied to both docker registry and helm chart repository.</span><br><span class="line">#registry_storage_provider can be: filesystem, s3, gcs, azure, etc.</span><br><span class="line">#registry_storage_provider_name = filesystem</span><br><span class="line">registry_storage_provider_name = s3</span><br><span class="line"></span><br><span class="line">#registry_storage_provider_config is a comma separated &quot;key: value&quot; pairs, e.g. &quot;key1: value, key2: value2&quot;.</span><br><span class="line">#To avoid duplicated configurations, both docker registry and chart repository follow the same storage configuration specifications of docker registry.</span><br><span class="line">#Refer to https://docs.docker.com/registry/configuration/#storage for all available configuration.</span><br><span class="line"></span><br><span class="line">#registry_storage_provider_config =</span><br><span class="line">#配置ceph 存储</span><br><span class="line">registry_storage_provider_config = bucket: f4gkewos23fdsf8fnfhG, region: default, accesskey: QaidfneuhgfE2dife, secretkey: qyIJDFNGIDNDKF8f2r3G5QSw, regionendpoint: http://ceph.chenzhijun.me, rootdirectory: /harbor-registry/di</span><br><span class="line"></span><br><span class="line">#registry_custom_ca_bundle is the path to the custom root ca certificate, which will be injected into the truststore</span><br><span class="line">#of registry&apos;s and chart repository&apos;s containers.  This is usually needed when the user hosts a internal storage with self signed certificate.</span><br><span class="line">registry_custom_ca_bundle =</span><br><span class="line"></span><br><span class="line">#If reload_config=true, all settings which present in harbor.cfg take effect after prepare and restart harbor, it overwrites exsiting settings.</span><br><span class="line">#reload_config=true</span><br><span class="line">#Regular expression to match skipped environment variables</span><br><span class="line">#skip_reload_env_pattern=(^EMAIL.*)|(^LDAP.*)</span><br></pre></td></tr></table></figure><p>配置好 cfg 文件后，我们开始我们的操作。</p><ol start="0"><li><p>申请或安装 ceph，ceph 版本为 12；</p></li><li><p>安装 pg 数据库(生产应为高可用)：</p></li></ol><p><code>docker run --name pg -e POSTGRES_PASSWORD=123456 -p 5432:5432 -d postgres:10.6</code></p><ol start="2"><li>安装 redis（生产因为高可用）：</li></ol><p><code>docker run --name redis -p 6379:6379 -d redis</code></p><ol start="3"><li>安装 harbor：</li></ol><p><code>./install.sh --with-clair --with-chartmuseum</code></p><p>这里除了 notaty 必须要有个 https 外，其他的你都可以装。clair 是镜像扫描工具；chartmuseum 是 helm chart ；<br>你需要在两台机器都启动，并且保持cfg 文件一致。</p><ol start="4"><li>配置 haproxy(F5)</li></ol><p>如果在 F5 做 https 转 http，那haproxy 就正常启动并将后段指向 harbor 地址就可以了。如果是让 https 做证书认证，那么就按照配置就好。我这边有在 F5 做解证书，贴一份 haproxy 的配置吧<code>haproxy.cfg</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">  daemon</span><br><span class="line">  log  127.0.0.1 local0 info</span><br><span class="line">  maxconn  20000</span><br><span class="line">  pidfile  /app/haproxy/run/haproxy.pid</span><br><span class="line">  stats  socket /app/haproxy/lib/haproxy/stats</span><br><span class="line">  tune.bufsize  131072</span><br><span class="line">  user mwop</span><br><span class="line">  group mwop</span><br><span class="line">  tune.ssl.default-dh-param 2048</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">  log  global</span><br><span class="line">  maxconn  10000</span><br><span class="line">  mode  http</span><br><span class="line">  option  dontlog-normal</span><br><span class="line">  option  http-server-close</span><br><span class="line">  retries  3</span><br><span class="line">  #stats  enable</span><br><span class="line">  timeout  http-request 100s</span><br><span class="line">  timeout  queue 1m</span><br><span class="line">  timeout  connect 10s</span><br><span class="line">  timeout  client 1m</span><br><span class="line">  timeout  server 30m</span><br><span class="line">  timeout  check 10s</span><br><span class="line"></span><br><span class="line">listen Stats</span><br><span class="line">  bind 0.0.0.0:10000</span><br><span class="line">  mode http</span><br><span class="line">  stats enable</span><br><span class="line">  stats uri /</span><br><span class="line">  stats refresh 5s</span><br><span class="line">  stats show-node</span><br><span class="line">  stats show-legends</span><br><span class="line">  stats hide-version</span><br><span class="line"></span><br><span class="line">listen app1</span><br><span class="line">    bind :80</span><br><span class="line">    balance     roundrobin</span><br><span class="line">    mode tcp</span><br><span class="line">    server s1  172.0.0.1:80   weight 1</span><br><span class="line">    server s2  172.0.0.2:80   weight 1</span><br><span class="line">    </span><br><span class="line">listen app2</span><br><span class="line">    bind :443 </span><br><span class="line">    balance     roundrobin</span><br><span class="line">    mode tcp</span><br><span class="line">    server s1  172.0.0.1:443   weight 1</span><br><span class="line">    server s2  172.0.0.2:443   weight 1</span><br></pre></td></tr></table></figure><p>访问<code>harbor.chenzhijun.me</code>就可以了。</p><p><img src="/images/qiniu/2020-04-26-21-43-00.png" alt="2020-04-26-21-43-00"></p><h3 id="https-问题-1-docker-login-failed"><a href="#https-问题-1-docker-login-failed" class="headerlink" title="https 问题 1 : docker login failed"></a>https 问题 1 : docker login failed</h3><p>安装完之后，你可能会遇到一些问题，比如在你直接 docker login 出现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: Get https://harbor.chenzhijun.me/v2/: Get http://harbor.chenzhijun.me/service/token?account=admin&amp;client_id=docker&amp;offline_token=true&amp;service=harbor-registry: dial tcp 100.77.53.130:80: getsockopt: connection refused</span><br></pre></td></tr></table></figure><p>你在页面登陆可以，当是你用 docker login却有问题。你可以<code>curl -X GET -I &quot;https://harbor.chenzhijun.me/v2/&quot;</code>看一下是否返回了一个 http 的请求。如果是的话，修改一个参数：<code>sed -i &quot;s/realm: http/realm: https/g&quot; common/config/registry/config.yml</code>;在<code>common/config/registry/config.yml</code>中修改返回值为 https：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auth:</span></span><br><span class="line">  <span class="attr">token:</span></span><br><span class="line">    <span class="attr">issuer:</span> <span class="string">harbor-token-issuer</span></span><br><span class="line">    <span class="attr">realm:</span> <span class="string">https://harbor.chenzhijun.me/service/token</span> <span class="comment">#就是这里要返回 https 而不是 http</span></span><br><span class="line">    <span class="attr">rootcertbundle:</span> <span class="string">/etc/registry/root.crt</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">harbor-registry</span></span><br></pre></td></tr></table></figure></p><p>这个地方改不是特别好改，我是在<code>install.sh</code>在 docker-compose启动之前加入的这个 sed 命令；</p><p><img src="/images/qiniu/2020-04-26-22-00-25.png" alt="2020-04-26-22-00-25"></p><p>然后再 curl 一下看是不是返回 https 的结果了。如果是就可以了。</p><h3 id="https-问题2-docker-push-出现-unkown-blob"><a href="#https-问题2-docker-push-出现-unkown-blob" class="headerlink" title="https 问题2 : docker push 出现 unkown blob"></a>https 问题2 : docker push 出现 unkown blob</h3><p>因为我们的架构是：域名 –&gt; dns解析到 –&gt; F5 VIP –&gt; haproxy –&gt; Harbor docker-compose;</p><p>在这个过程中，出现了一个问题。域名到到 F5是 https，而后面的 Harbor 接到的 http；所以在 docker login 成功。在 docker push 的时候出现了问题 <code>unkown blob</code>；这个问题的原因就是在反向代理中 harbor 的 nginx 代理用的还是 https 方式：<a href="https://github.com/goharbor/harbor/blob/release-1.7.0/docs/installation_guide.md#Troubleshooting" target="_blank" rel="noopener">Harbor Troubleshooting</a>。修改<code>common/templates/nginx/nginx.http.conf</code>中的<code>proxy_set_header X-Forwarded-Proto $scheme;</code>把这行注释掉就可以了。</p><p>另外就是要注意 pg 的权限问题。</p><h3 id="https-问题3-docker-push-出现-unauthorized-authentication-required"><a href="#https-问题3-docker-push-出现-unauthorized-authentication-required" class="headerlink" title="https 问题3: docker push 出现 unauthorized: authentication required"></a>https 问题3: docker push 出现 unauthorized: authentication required</h3><p>这是一个很诡异的问题，找了我两个小时；现象是harbor 的页面能登陆，并且页面一切功能正常；直接使用 docker login 也是没有问题，但是在 push 镜像的时候出现，unauthorized: authentication required;明明已经登陆了，也没有问题，但是不知道为啥还是会报错。这个问题在我这里是由于 haproxy 的配置出现的问题。harbor push 镜像的过程是从 harbor 服务获取一个 token，然后再去访问 registry 的存储来存储数据，如果是是本地存储，那么会访问 80 端口。我的配置中将 haproxy 的 80 端口转了 redirect，所以导致认证失败。附上一段在 haproxy 段做证书解析而后端 harbor 为 http 的 haproxy 的服务配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">frontend harbor</span><br><span class="line">  bind *:80</span><br><span class="line">  bind *:443 ssl crt /data/harbor/harbor/chenzhijun.me.pem</span><br><span class="line">  reqadd X-Forwarded-Proto:\ https</span><br><span class="line">  default_backend  harbor-backend</span><br><span class="line"></span><br><span class="line">backend harbor-backend</span><br><span class="line">  balance  source</span><br><span class="line">  mode  http</span><br><span class="line">  timeout  client 3h</span><br><span class="line">  timeout  server 3h</span><br><span class="line">  server server1 10.1.1.2:80  check inter 2000 fall 3</span><br></pre></td></tr></table></figure><p>如果还是有问题，可以在<code>/var/log/harbor</code>目录下查看相关的 log 日志。也可以查看系统日志：<code>/var/log/message</code>来定位问题。</p><p>我们也安装了 <code>/install.sh --with-clair --with-chartmuseum</code> clair 和 chartmuseum，这两个工具，clair 的主要目的是扫描 CVE 漏洞，所以是不是需要链接一下外网更新一下；chartmuseum 是一个 helm chart 管理器;</p><p><img src="/images/qiniu/2020-04-26-22-15-03.png" alt="2020-04-26-22-15-03"></p><p><img src="/images/qiniu/2020-04-26-22-16-24.png" alt="2020-04-26-22-16-24"></p><h2 id="升级问题"><a href="#升级问题" class="headerlink" title="升级问题"></a>升级问题</h2><p>最近尝试在本地进行了一次 1.7 升级到 1.8，其实还好啊，就是 cfg 文件变成了 yml 文件，其他的还是一样。并且有迁移工具：<br><a href="https://github.com/goharbor/harbor/blob/release-1.8.0/docs/migration_guide.md" target="_blank" rel="noopener">https://github.com/goharbor/harbor/blob/release-1.8.0/docs/migration_guide.md</a></p><p>迁移工具使用方式：</p><p><code>docker run -it --rm -v /data/harbor/harbor/harbor.cfg:/harbor-migration/harbor-cfg/harbor.cfg -v /data/harbor/harbor/harbor.yml:/harbor-migration/harbor-cfg-out/harbor.yml harbor.uat.cmft.com/goharbor/harbor-migrator:v1.8.3 --cfg up</code></p><p>然后就停掉原来的 1.7 使用新的 1.8 的安装包启动就可以了。</p><p>迁移前一定要进行数据备份，一定要备份。</p><h2 id="helm-使用"><a href="#helm-使用" class="headerlink" title="helm 使用"></a>helm 使用</h2><p>helm 在 v3 之后（我只用了 v3）其实特别好用。在 github 上下载 helm 的安装包，然后把 helm 放到 /usr/local/bin 下面就可以直接执行 helm 命令了。当然前提是要本机有 kubectl，并且本地有 kubeconfig 文件<code>~/.kube/config</code>。这样我们就能愉快的使用 helm 了。那我们怎么使用 harbor 来管理我们的 helm chart 了？</p><p><code>helm repo add --username readonly --password Read2019 myharbor http://harbor.chenzhijun.me/chartrepo/helm-repo</code></p><p><code>http://harbor.chenzhijun.me/chartrepo/</code> 这一段是固定的，<code>helm-repo</code>是 harbor 中的 project 名。然后你将一个 chart 包导入：</p><p><img src="/images/qiniu/2020-04-26-22-25-53.png" alt="2020-04-26-22-25-53"></p><p><code>helm search repo myharbor</code></p><p><code>helm repo update</code></p><p><code>helm install myharbor/consul --gernerate-name</code></p><p>好了，就是这么简单粗暴。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Harbor-镜像仓库安装与-Helm-Chart-管理&quot;&gt;&lt;a href=&quot;#Harbor-镜像仓库安装与-Helm-Chart-管理&quot; class=&quot;headerlink&quot; title=&quot;Harbor  镜像仓库安装与 Helm Chart 管理&quot;&gt;&lt;/a&gt;Harbor  镜像仓库安装与 Helm Chart 管理&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://goharbor.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Harbor&lt;/a&gt; 是一款非常优秀的企业级开源镜像仓库管理器。Harbor 是基于 Docker Registry之上带有用户权限控制，镜像扫描，镜像签名的款工具。用起来很方便，我们公司目前在测试和生产都在使用。从去年 10 月到今天，除去一次 ceph 集群扩容，没有发生一次事故，一直运行很稳定；本文将记录一下我们的使用方式和遇到的一些问题解决方式。&lt;/p&gt;
&lt;h2 id=&quot;Harbor-资源准备&quot;&gt;&lt;a href=&quot;#Harbor-资源准备&quot; class=&quot;headerlink&quot; title=&quot;Harbor 资源准备&quot;&gt;&lt;/a&gt;Harbor 资源准备&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Harbor 1.7.6 版本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Redis 4.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Postgres 10.6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Docker 1.13.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker-compose 1.18.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ceph 12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;haproxy 机器 2 台&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;VIP 1 个&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Harbor 主机 2 台&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;公司目前的 harbor 是基于 1.76 搭建的高可用方案，证书的问题，我们是公网使用第三方证书。内网使用自签名的证书；在我这里，我在 harbor 的搭建中采用的是内部 http，外部挂 F5。架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/qiniu/2020-04-26-21-15-43.png&quot; alt=&quot;2020-04-26-21-15-43&quot;&gt;&lt;/p&gt;
&lt;p&gt;生产上我们用 F5 替代 Haproxy。&lt;/p&gt;
&lt;p&gt;我们在 Haproxy/F5 层将 https 转成 http 再转发给内部 harbor。&lt;br&gt;
    
    </summary>
    
      <category term="Harbor" scheme="http://chenzhijun.me/categories/Harbor/"/>
    
    
      <category term="Harbor" scheme="http://chenzhijun.me/tags/Harbor/"/>
    
  </entry>
  
  <entry>
    <title>查漏补缺 Java 系列 - JVM 垃圾回收</title>
    <link href="http://chenzhijun.me/2020/04/05/what-is-garbage-to-need-collecter/"/>
    <id>http://chenzhijun.me/2020/04/05/what-is-garbage-to-need-collecter/</id>
    <published>2020-04-05T04:50:01.000Z</published>
    <updated>2020-05-13T13:33:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查漏补缺-Java-系列-JVM-垃圾回收"><a href="#查漏补缺-Java-系列-JVM-垃圾回收" class="headerlink" title="查漏补缺 Java 系列 - JVM 垃圾回收"></a>查漏补缺 Java 系列 - JVM 垃圾回收</h1><p>正如一间房子，房子的主人肯定需要在客人来的时候进行一些收拾，让家里显得更加的大，而让客人有更好的体验。JVM 也是一样，你想想，JVM 是不是也要不定时的清理下内存区域空间以便能让更多的线程有更好的执行体验？那主人在进行清理的时候，至少要知道要对哪个区域进行清理吧？要知道在哪个区域清理哪些垃圾吧？清理的过程是用拖把还是用扫把，要有个选择吧？你想想 JVM 是不是也应该是类似的？</p><h2 id="JVM-应该回收哪个区域的垃圾？"><a href="#JVM-应该回收哪个区域的垃圾？" class="headerlink" title="JVM 应该回收哪个区域的垃圾？"></a>JVM 应该回收哪个区域的垃圾？</h2><p>上一篇，我们介绍了 jvm 中一些基础概念，包括运行时内存区域。其中我们知道 jvm 规范中规定了5个运行时区域，一器两栈一堆一区。程序计数器，Java 虚拟机栈，本地方法栈，堆，方法区【运行时常量池（方法区内部）】；</p><p>JVM 这些区域里面我们可以分两类，一类需要重点关注 GC，一点可以不需要 GC。根据它们的生命周期可以看到虚拟机栈、本地方法栈、程序计数器这三个线程私有的区域，他们的生命周期跟线程的生命周期保持一样，他们的内存分配和回收时间是可以确定的，所以基本上用不上 GC；而方法区，堆他们需要在程序实际运行时才能知道需要创建哪些对象分配多大的空间，所以这部分是重点要关注的 GC 区域；</p><p>我们根据分配的时机来确定了需要进行垃圾回收的两个区域：堆，方法区。但是在 jvm 规范中对方法区进行了一个定义，也就是这块区域逻辑上属于堆，但是它可以不用 GC（上篇文章我有说到）。因此我们将重点放到堆（Heap）的回收中。</p><p>好了，我们现在知道哪个区域需要进行 GC 了，那么 JVM 又如何知道哪些是垃圾需要清理，哪些不是垃圾不需要清理了？因为堆主要是用来存放对象的，我们也可以当做，jvm 应该怎么判读一个对象是不是应该被回收？<br><a id="more"></a></p><h2 id="JVM-怎么判断是不是要回收的对象？"><a href="#JVM-怎么判断是不是要回收的对象？" class="headerlink" title="JVM 怎么判断是不是要回收的对象？"></a>JVM 怎么判断是不是要回收的对象？</h2><p>判断一个对象是不是应该被回收，通常是认为这个对象是否存活（有用）。判断的方式一般可以选择下面两种方法：1，引用计数法；2，可达性分析法。</p><p><code>引用计数法</code>就是给对象加一个引用计数器，每一次被引用到就加1，解除引用就减1。如果为 0 那就认为是需要被回收的，不能再继续使用了。这种方法效率高，一般情况下其实还不错，但是有个隐藏的问题，那就是对象之间的循环引用问题。</p><p>什么是循环引用呢？看下面的代码你就能很好地理解了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class CircularReference &#123;</span><br><span class="line">    public Object instance = null;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CircularReference objA = new CircularReference();</span><br><span class="line">        CircularReference objB = new CircularReference();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = null;</span><br><span class="line">        objB = null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方式就是<code>可达性分析法</code>，可达性分析就是从一个起始点出发（GC Roots），从这个节点往下搜索节点，两个点之间的路径叫做引用链条（Reference Chain）。当一个对象到 GC Roots 之间没有任何一条引用链，我们判断这个节点是可回收的对象。</p><p>可达性的图类似于下面这样：</p><p><img src="/images/qiniu/2020-04-05-14-59-07.png" alt="2020-04-05-14-59-07"></p><p>可达性分析可以解决循环引用的问题，你看上图的 a，b两个对象。从 GC Root 到 a,b 两者间是没有引用链的，所以是可以认为a,b 可以回收。但是 a，b 一定会回收吗？可达性分析的过程中，会要进行两次标记才能确定对象是否可以被回收，第一次可达性分析中，会将没有引用链的对象进行第一次标记并且进行一次筛选。筛选的条件主要是看对象是否有必要执行finalize()方法，如果对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用了，虚拟机认为这两种情况都属于“没有必要执行”。所以在被回收前，他们还是有一次机会进行“自救”的。如果第二次标记的时候对象还是没有引用链，那么就真的被回收了。</p><blockquote><p>虚拟机进行了一轮筛选后会将有必要执行 finalize()方法的对象发到一个 F-Queuen 的队列中，然后创建一个 Finalizer 线程去执行它。这里要注意虚拟机会触发执行它，但不承偌会等待其运行完，这样做的目的是为了防止 finalize() 方法执行缓慢，或者死循环，这样会导致 F-queuen 里面的所有对象都会处于永久等待状态，也可能导致整个内存回收系统崩溃。</p></blockquote><p>这是两种常用的判断对象是否可以进行回收的方法。</p><p>我们举个例子子说明：<br>假设现在你要堆家里进行大扫除，你需要整理一些垃圾扔掉，你应该怎么做？</p><p>如果你在家里做过大扫除，你肯定需要对物品进行判断是不是应该进行清理，你判断的方式可能是两种：1. 物品是属于谁的（开玩笑，要是你把女朋友的口红扔了试试？）；2. 物品还能不能用？</p><p>假设你跟你女朋友住一起，在打扫客厅的时候看到了一个空的薯片桶盒，你会想这是谁吃的，自己没吃过，问了女朋友，她也说没吃过。好了，反正就是没人认啦，然后这个盒子对于你是否有用了？至少对于大部分人来说是没用了（废物回收者除外），所以你就判断它是垃圾了。对吧。这是不是有点类似于引用计数法？有人用就+1，没人用就-1，为 0 就回收啊。</p><p>然后，你在打扫沙发的时候发现了一个未拆封的礼品盒，你确认这不是你的。然后你问你女朋友，这是不是她的？她说，这不是她的，但是这是她给她闺蜜买的礼物。这个时候你可以认为这个礼物属于女朋友闺蜜，女朋友闺蜜和女朋友有关联。你看这是不是可达？这个礼品盒（对象）和GC ROOT（女朋友）之间是不是有个引用链？那这个肯定就不是垃圾了。对吧。</p><h2 id="JVM-该怎么回收垃圾了？"><a href="#JVM-该怎么回收垃圾了？" class="headerlink" title="JVM 该怎么回收垃圾了？"></a>JVM 该怎么回收垃圾了？</h2><p>刚也说了，垃圾已经找出来了，但是现在就是要清理垃圾了。你把客厅的垃圾都扫出来了，总不可能就放在哪里不管了吧？</p><p>在 jvm 中有四个主要的垃圾收集算法：</p><ol><li>标记-清除算法；</li><li>复制算法；</li><li>标记-整理算法；</li><li>分代收集算法；</li></ol><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>先根据可达性分析标记出哪些需要进行回收，然后将对象进行回收。大致步骤：</p><ol><li>标记垃圾；</li><li>直接回收垃圾；</li></ol><p><img src="/images/qiniu/2020-04-06-18-26-50.png" alt="2020-04-06-18-26-50"></p><p>看图片就知道，实现的步骤很简单，就是标记，然后清除掉。这样的方式很简单暴力，但是也带来了问题，那就是不连续的内存段，导致空间浪费。空间浪费的原因就是它造成了很多碎片内存，你想啊，你要一个 3M 的连续内存空间，但是内存里面都是分散的 1M 的空间，你说气不气人？白白浪费了，不持家啊~~</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法的流程大致如下：</p><ol><li>标记哪些是可回收的，哪些是使用中的；</li><li>将使用中的对象复制到内存的另一半空闲中；</li><li>清理掉需要回收的原来的一半内存；</li></ol><p><img src="/images/qiniu/2020-04-06-18-21-37.png" alt="2020-04-06-18-21-37"></p><p>复制算法的思路很清晰，就是把一块内存劈成两半，然后一半内存满了，就把这一半内存中有用的全部移动到另一个内存空间，再把原来满的一半全部清了。这种算法其实很好啊，你看就解决了内存不足的问题（可以回收），也解决了内存碎片的问题（复制的时候是连续的）。就是有个不好，明明有 100M 内存，但是你就是只能用 50M，你说气人不气人。另外复制算法带来了一个隐藏的问题，如果使用的一半内存中有 90% 的对象都是需要用到的，那可是要复制 90% 的对象到另一半中啊。你说怎么办？看下面的另一个算法</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>如果复制的内容过多，那我们是不是可以不复制了？标记整理算法就可以这样。它的原理就是我把所有需要使用到的对象都往一边移动，然后移动到最后一个对象的时候，作为边界，把边界之后的全部删除掉，这样是不是就可以了？</p><p><img src="/images/qiniu/2020-04-06-18-43-10.png" alt="2020-04-06-18-43-10"></p><p>这样算法就是明显的使用的空间大了，但是如果是很多对象都存活着的话，那也是移动效率有点慢。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集算法它其实是一种组合算法，我们可以看到上面的几个优缺点，标记清除有简单性，但是可能造成内存碎片；复制算法做到了内存的连续性，但是可能有大量复制（存货对象过多）而且内存利用率不太好；标记-整理算法看起来很不错，但是如果是只有少量的需要垃圾回收的对象了？那么移动每个对象就变成了很麻烦的操作。所以分代搜集算法就是在这种情况下产生的，既然其它算法都有好处，那我可不可以将一块大内存，划分为几块大小不一样的内存，然后每块内存里面采用不同的算法？这在虚拟机的实现过程中也是有这种考量的，比如 hotspot 虚拟机实现中就有下面的一个对象存活时间分析图：</p><p><img src="/images/qiniu/2020-04-06-21-08-37.png" alt="2020-04-06-21-08-37"></p><blockquote><p>图地址为：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#distribution_lifetimes" target="_blank" rel="noopener">distribution_lifetimes</a></p></blockquote><p>可以看到如果以 x 轴为对象的生命周期，y 轴为对象内存分配空间。会发现很对的对象其实都是只有很短的生命周期，换通俗点说，就是很多对象可能就是朝生夕死；换人来说的话：吾朝闻道夕死可矣；换“对象(instance)”来说的话：活已经干完了，要杀要剐你看着办吧。总之你要知道，很多对象的生命周期都是很短的，所以如果不采用分代收集的话，那么对于一整块内存来说，最后做 GC 这个工作量会很大。</p><p>主流的虚拟机就开始想了个办法，既然一整块去收集集工作量大，那我可不可以让这个 GC 的时间提早？我把内存划分为几个区域，然后每个区域分代去回收内存是不是效率就高了？于是就有了我们现在的主流，根据对象的存活年龄来分代。</p><p><img src="/images/qiniu/2020-04-06-21-46-15.png" alt="2020-04-06-21-46-15"></p><p>对图中的几个区域做下说明：</p><p>virtual：在初始化的时候会预留一块内存区域，这个区域除非是必要时候，不然不会分配实际物理内存；<br>Eden 区：年轻代中的 eden 区，对象开始分配空间的主区域，young gc 的主区域；<br>s0：年轻代中的幸存者区域之一，结合我们说的复制算法，eden 区的内存复制到这里；<br>s1：年轻代中的幸存者区域之一，跟 s0 的作用一样；<br>Tenured：永久代/老年代，存放幸存者达到一定年龄的对象；</p><blockquote><p>空间比：Eden:s0:s1 = 8:1:1</p></blockquote><p>这里需要说明一下 s0,s1 两个区域，这两个区域的作用不仅仅是将 eden 区存活的幸存对象复制保存下来，他们自己本身也会进行 gc，比如 s0 里面满了，那么下次年轻代 gc (又叫minor gc)的时候，s0 中存活的对象复制到 s1 中；再下次年轻代 gc 的时候，s1 又把自己本身存活的对象复制到 s0 中，这样每经过一次 minor gc，对象的年龄就+1，达到我们设定的阈值比如 15，就会进入到永久代。</p><h2 id="GC-过程"><a href="#GC-过程" class="headerlink" title="GC 过程"></a>GC 过程</h2><h3 id="minor-GC"><a href="#minor-GC" class="headerlink" title="minor GC"></a>minor GC</h3><p>我们看下一个对象的从创建到最后升级到永久代的过程(多次的 minorGC)：</p><ol><li>先在 eden 区创建一个对象：</li></ol><p><img src="/images/qiniu/2020-04-06-22-09-02.png" alt="2020-04-06-22-09-02"></p><ol start="2"><li>Eden 区要满了，准备触发 minorGC：</li></ol><p><img src="/images/qiniu/2020-04-06-22-09-53.png" alt="2020-04-06-22-09-53"></p><ol start="3"><li>触发一次 minorGC 将 eden 区的一部分存活对象移动到 s0 中：</li></ol><p><img src="/images/qiniu/object-minor-gc-1.gif" alt="object-minor-gc-1"></p><ol start="4"><li>触发下一次 minorGC，将其一定到另一个 s1 中：</li></ol><p><img src="/images/qiniu/object-minor-gc-2.gif" alt="object-minor-gc-2"></p><ol start="5"><li>如果到了我们设定的阈值，就晋升到永久代：</li></ol><p><img src="/images/qiniu/object-minor-gc-3.gif" alt="object-minor-gc-3"></p><p>如果有一个对象需要大量的连续内存时，这种特殊情况下对象的创建不会在 Eden 区，而是直接在老年代。因为如果放在 eden 区，minorGC 进入到 s0、s1 会导致这块很快就空间满了，空间满了就会又开始 gc，那不是费时费力吗，所以直接放到老年代。</p><h3 id="Major-GC-Full-GC"><a href="#Major-GC-Full-GC" class="headerlink" title="Major GC(Full GC)"></a>Major GC(Full GC)</h3><p>上面讲的是 minorGC，那么我们可以想一下，如果在对象到了我们设定的阈值，需要进入永久代了，我们是不是应该要先检查下当前永久代代的空间是不是还够年轻代进行 minorGC？这个叫做空间分配保障。那么怎么保障？如果当前永久代剩余空间大于年轻代的总空间，那肯定没问题，你 minorGC 继续。如果发现当前空间小与年轻代总空间，虚拟机会去查一下HandlePromotionFailure是否允许担保。如果设置为允许，那么怎么办？虚拟机按照以前的 minorGC 晋升到永久代的平均大小，如果大，就 minorGC，如果小就进行 FullGC。</p><p>如果永久代也满了，那么 FullGC 肯定也会触发了。</p><p>FullGC 的过程是堆整个堆进行全量 GC，同时回收年轻代和永久代，会导致一个STW（Stop The World），很好理解啊，我都要进行全家大扫除了，你给我说，你还要继续嗑瓜子？？</p><p>好了，今天写到这里，前面讲了内存区域，今天讲了垃圾标识和常见的算法。明天继续写安全点和常见的几个垃圾收集器。之后再写 GC 日志分析，发生 OOM 线上怎么调试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查漏补缺-Java-系列-JVM-垃圾回收&quot;&gt;&lt;a href=&quot;#查漏补缺-Java-系列-JVM-垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;查漏补缺 Java 系列 - JVM 垃圾回收&quot;&gt;&lt;/a&gt;查漏补缺 Java 系列 - JVM 垃圾回收&lt;/h1&gt;&lt;p&gt;正如一间房子，房子的主人肯定需要在客人来的时候进行一些收拾，让家里显得更加的大，而让客人有更好的体验。JVM 也是一样，你想想，JVM 是不是也要不定时的清理下内存区域空间以便能让更多的线程有更好的执行体验？那主人在进行清理的时候，至少要知道要对哪个区域进行清理吧？要知道在哪个区域清理哪些垃圾吧？清理的过程是用拖把还是用扫把，要有个选择吧？你想想 JVM 是不是也应该是类似的？&lt;/p&gt;
&lt;h2 id=&quot;JVM-应该回收哪个区域的垃圾？&quot;&gt;&lt;a href=&quot;#JVM-应该回收哪个区域的垃圾？&quot; class=&quot;headerlink&quot; title=&quot;JVM 应该回收哪个区域的垃圾？&quot;&gt;&lt;/a&gt;JVM 应该回收哪个区域的垃圾？&lt;/h2&gt;&lt;p&gt;上一篇，我们介绍了 jvm 中一些基础概念，包括运行时内存区域。其中我们知道 jvm 规范中规定了5个运行时区域，一器两栈一堆一区。程序计数器，Java 虚拟机栈，本地方法栈，堆，方法区【运行时常量池（方法区内部）】；&lt;/p&gt;
&lt;p&gt;JVM 这些区域里面我们可以分两类，一类需要重点关注 GC，一点可以不需要 GC。根据它们的生命周期可以看到虚拟机栈、本地方法栈、程序计数器这三个线程私有的区域，他们的生命周期跟线程的生命周期保持一样，他们的内存分配和回收时间是可以确定的，所以基本上用不上 GC；而方法区，堆他们需要在程序实际运行时才能知道需要创建哪些对象分配多大的空间，所以这部分是重点要关注的 GC 区域；&lt;/p&gt;
&lt;p&gt;我们根据分配的时机来确定了需要进行垃圾回收的两个区域：堆，方法区。但是在 jvm 规范中对方法区进行了一个定义，也就是这块区域逻辑上属于堆，但是它可以不用 GC（上篇文章我有说到）。因此我们将重点放到堆（Heap）的回收中。&lt;/p&gt;
&lt;p&gt;好了，我们现在知道哪个区域需要进行 GC 了，那么 JVM 又如何知道哪些是垃圾需要清理，哪些不是垃圾不需要清理了？因为堆主要是用来存放对象的，我们也可以当做，jvm 应该怎么判读一个对象是不是应该被回收？&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://chenzhijun.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://chenzhijun.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>查漏补缺 Java 系列 - JVM 基础概念</title>
    <link href="http://chenzhijun.me/2020/04/04/what-is-jvm-when-we-talk-about-it/"/>
    <id>http://chenzhijun.me/2020/04/04/what-is-jvm-when-we-talk-about-it/</id>
    <published>2020-04-04T07:15:49.000Z</published>
    <updated>2020-05-13T13:33:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查漏补缺-Java-系列-JVM"><a href="#查漏补缺-Java-系列-JVM" class="headerlink" title="查漏补缺 Java 系列 - JVM"></a>查漏补缺 Java 系列 - JVM</h1><p>你知道 JVM 吗?作为Java开发人员，我想你肯定听过吧?那么你了解为什么需要 JVM 吗?它的作用是什么?给我带来了什么好处，又给我们带来了什么缺点了?接下来我们一起看看吧。</p><h2 id="JVM-的基础概念"><a href="#JVM-的基础概念" class="headerlink" title="JVM 的基础概念"></a>JVM 的基础概念</h2><p>什么是 JVM ? </p><p>JVM(Java Virtual Machine) 中文名称为 Java 虚拟机。它的作用是为 Java 提供跨平台运行的基础，也就是那句”一次编译，到处运行”的底层保证。 </p><p>我想你肯定在 windows，Linux，MacOS 上都有运行过 Java 程序，那么你想一想，在一台裸机上面(指新买的机器装上一个纯的干净的系统 OS)，你直接编写一个 Main。java 能运行起来么?运行一个 Main。java，我想你肯定经过这几个步骤:安装 jdk(jre) -&gt; 编写 Main。java -&gt; <code>javac Main。java</code>生成<code>main。claas</code>文件 -&gt; <code>java Main</code>;那你想过吗?为什么你要安装一个 jkd(jre)，为什么你要先用<code>javac</code>命令，生成一个<code>claas</code>文件，然后才能执行了?</p><p>你肯定有疑问。是的。我想跟你说的是其实 jvm 根本不知道你写的 java 文件里面的内容，一点都不知道。但是它认识你按照它的规范生成的 class 文件。然后它再将 class 文件翻译成机器识别的机器码。这样才能真正的运行你的程序了。也许这就是为什么很多人会说它是解释器吧。<br><a id="more"></a></p><h2 id="JVM-都含有什么"><a href="#JVM-都含有什么" class="headerlink" title="JVM 都含有什么?"></a>JVM 都含有什么?</h2><p>我们知道 java 代码要在 jvm 里面运行的话，上面的概念解释中也说了，它需要由 java 编译器生成 class 字节码文件，然后再由 jvm 将字节码 class 文件翻译成底层不同的平台所能识别的机器码。那么在读取到解释成为字节码的过程中，它肯定需要进行一些操作，它进行操作肯定也就避免不了要使用一些工具（或者我们称之为资源）。它要用到的资源就是内存。就像我们住在自己的房子里面一样，我们肯定会要定下来，哪里是我们的卧室，哪里是我们的厨房，哪里是我们的客厅，哪个地方是书房等等。JVM 也是一样。JVM 将它所管理的内存分为了几个运行时数据区域。那么 JVM 有哪几个区域呢？看 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">Run-Time Data Areas</a> 总共是 5 个运行时数据区：程序计数器（PC register），Java 虚拟机栈（Java Virtual Machine Stacks），堆（Heap），方法区（Method Area），运行时常量池（Run-Time Constant Pool），本地方法栈（Native Method Stacks）。</p><ol><li><p>程序计数器（PC register）：线程私有；jvm 中每一个线程都会有的一块区域，如果是非本地方法（not native thread）的线程，会保存一个当前指令的执行地址；如果是本地方法的线程（native thread）,这个位置就为空（undefined）；这块的空间足够大，大到足够支持所有的指令地址和本地方法指针，所以这块不会出现 OOM 的时候。（原话：The Java Virtual Machine’s pc register is wide enough to hold a returnAddress or a native pointer on the specific platform.）</p></li><li><p>Java 虚拟机栈（Java Virtual Machine Stacks）：线程私有；每个线程创建的时候同步创建这块区域与线程的生命周期相同；它的主要主要作用是用来存储<a href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener">栈帧</a>（Frame）；它存储局部变量，操作数栈，动态链接，方法调用，方法返回值等信息；Java 虚拟机栈的空间分配可以是不连续的一段内存空间；jvm 规范规定这块的空间可以是固定大小，也可以是动态的大小，由具体的虚拟机实现。在 Java 虚拟机栈中，如果一个运行中的线程请求比 jvm 允许的栈大小更大的空间，jvm 就会直接抛出<code>StackOverflowError</code>；如果是动态扩容机制，当本地内存不足的时候，会抛出<code>OutOfMemoryError</code>。</p></li><li><p>堆（Heap）：是一块线程共享的区域，在 java 虚拟机启动的时候就会被创建，主要作用是用来储存对象实例和数组。这块区域可以被垃圾回收器回收，如果需要的资源比垃圾回收期回收后释放出来的资源还要大，那它就会抛出<code>OutOfMemoryError</code>。实际上，这块区域可以设置为动态扩缩容，应该提供设置最大堆内存和最小堆内存的方法。这块区域的空间申请可以是不连续的空间。</p></li><li><p>方法区（Method Area）：方法区是一个线程共享区域，在 java 虚拟机启动的时候会被创建，主要用来存储每个类的结构，比如说类信息，常量，静态变量，方法和构造方法等。逻辑上它是堆（Heap）的一个区域，但是简单实现它可以不需要使用垃圾回收期回收它。如果需要动态调节它的大小，应该提供最大空间和最小空间的设定方法。如果方法区的内存不够分配了，应该要抛出<code>OutOfMemoryError</code>异常。</p></li><li><p>运行时常量池（Run-Time Constant Pool）：属于方法区的一部分，在类或者接口创建的时候生成，主要用来存储编译期间的各种字面量和符号引用。运行时常量池对于 Class 文件有动态性，不要求常量一定只有编译期才能产生，也可以在运行期加入新的常量，比如使用 String.intern（）方法。如果该区的空间不够，那么就会跟方法区一样抛出<code>OutOfMemoryError</code>异常。</p></li><li><p>本地方法栈（Native Method Stacks）：这个有点类似于 Java 虚拟机栈，虚拟机栈是为执行 Java 方法服务，本地方法栈则为调用 native 方法服务，也会抛出<code>StackOverflowError</code>,<code>OutOfMemoryError</code>异常。</p></li><li><p>直接内存/堆外内存：我在官网的介绍中其实并没有看到这个，但是我看书（《深入理解 Java 虚拟机上》）里面介绍，就一起放到这里了。这块的空间其实就是系统内存中除了分配给 jvm 那些数据区域的，剩下的内存。这块的空间受限于机器本身的内存总大小。这块的作用其实就类似于 NIO 中的 channel 直接操作 Native 函数库直接分配堆外内存。</p></li></ol><blockquote><p>ps 方法区很多人也叫永久代（permanent Generation），本质上两者并不等价，这只是 hotspot 虚拟机的一种具体实现而已，用永久代来实现方法区。书是基于 jdk1.7 的，1.8 中 PermGen 已经被去掉了<a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">whats-new-on-jdk-8</a>。</p></blockquote><p>现在你知道了上面定义的 6 个内存 jvm 运行区域，但是在各家的 jvm 虚拟机实现中有点不同。比如 HotSpot，其实我们可以看到只要有上面的规定的 6 个运行时区就行了，毕竟这是规范，具体实现肯定不同：</p><p><img src="/images/qiniu/2020-04-04-23-12-46.png" alt="2020-04-04-23-12-46"></p><p>了解这么多的内存区域，那么它是怎么识别一个对象是否应该被回收？怎么回收空间的了？用到了什么算法？<br>明天继续！</p><p>参考资料：</p><p><a href="https://blog.csdn.net/zhenghongcs/article/details/104628800" target="_blank" rel="noopener">jvm</a></p><p><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">Java Language and Virtual Machine Specifications</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html" target="_blank" rel="noopener">gc 调优-官网文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查漏补缺-Java-系列-JVM&quot;&gt;&lt;a href=&quot;#查漏补缺-Java-系列-JVM&quot; class=&quot;headerlink&quot; title=&quot;查漏补缺 Java 系列 - JVM&quot;&gt;&lt;/a&gt;查漏补缺 Java 系列 - JVM&lt;/h1&gt;&lt;p&gt;你知道 JVM 吗?作为Java开发人员，我想你肯定听过吧?那么你了解为什么需要 JVM 吗?它的作用是什么?给我带来了什么好处，又给我们带来了什么缺点了?接下来我们一起看看吧。&lt;/p&gt;
&lt;h2 id=&quot;JVM-的基础概念&quot;&gt;&lt;a href=&quot;#JVM-的基础概念&quot; class=&quot;headerlink&quot; title=&quot;JVM 的基础概念&quot;&gt;&lt;/a&gt;JVM 的基础概念&lt;/h2&gt;&lt;p&gt;什么是 JVM ? &lt;/p&gt;
&lt;p&gt;JVM(Java Virtual Machine) 中文名称为 Java 虚拟机。它的作用是为 Java 提供跨平台运行的基础，也就是那句”一次编译，到处运行”的底层保证。 &lt;/p&gt;
&lt;p&gt;我想你肯定在 windows，Linux，MacOS 上都有运行过 Java 程序，那么你想一想，在一台裸机上面(指新买的机器装上一个纯的干净的系统 OS)，你直接编写一个 Main。java 能运行起来么?运行一个 Main。java，我想你肯定经过这几个步骤:安装 jdk(jre) -&amp;gt; 编写 Main。java -&amp;gt; &lt;code&gt;javac Main。java&lt;/code&gt;生成&lt;code&gt;main。claas&lt;/code&gt;文件 -&amp;gt; &lt;code&gt;java Main&lt;/code&gt;;那你想过吗?为什么你要安装一个 jkd(jre)，为什么你要先用&lt;code&gt;javac&lt;/code&gt;命令，生成一个&lt;code&gt;claas&lt;/code&gt;文件，然后才能执行了?&lt;/p&gt;
&lt;p&gt;你肯定有疑问。是的。我想跟你说的是其实 jvm 根本不知道你写的 java 文件里面的内容，一点都不知道。但是它认识你按照它的规范生成的 class 文件。然后它再将 class 文件翻译成机器识别的机器码。这样才能真正的运行你的程序了。也许这就是为什么很多人会说它是解释器吧。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://chenzhijun.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://chenzhijun.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java HashMap</title>
    <link href="http://chenzhijun.me/2020/03/25/java-map-hashmap-concurrenthashmap/"/>
    <id>http://chenzhijun.me/2020/03/25/java-map-hashmap-concurrenthashmap/</id>
    <published>2020-03-25T14:57:59.000Z</published>
    <updated>2020-05-13T13:33:03.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap-介绍"><a href="#HashMap-介绍" class="headerlink" title="HashMap 介绍"></a>HashMap 介绍</h1><p>这个该怎么写了？其实网上好多博客说了这个，其实我看了之后，甚至看了源码之后我也不知道怎么写，源码中Hashmap的介绍大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hashmap 大致是等于hashtable的，除了非同步和允许null值之外；</span><br><span class="line">不保证数据的顺序；</span><br><span class="line">常数级别的get和put；</span><br><span class="line">最重要性能的两个属性： capacity  ， loadfactor</span><br><span class="line">0.75的加载因子数是一种空间和时间上的tradeoff（平衡）</span><br><span class="line">相同的hashcode()会降低它的性能</span><br><span class="line">hashmap的实现是非同步的；</span><br><span class="line">iterator fail-fast ConcurrentModificationException.</span><br></pre></td></tr></table></figure><p>首先我们介绍下它的内部数据结构吧。</p><h2 id="HashMap的内部结构"><a href="#HashMap的内部结构" class="headerlink" title="HashMap的内部结构"></a>HashMap的内部结构</h2><a id="more"></a><p>Hashmap 是由<code>Node&lt;K,V&gt;[] table</code>和链表组成的结构，数组被分为一个个的桶（bucket），通过 hash 值在这个桶上进行寻址。hash 值相同的键值对就以链表的形式存储，如果链表的大小超过 <code>TREEIFY_THRESHOLD=8</code>就会将链表进行树化。</p><p><img src="/images/qiniu/2020-03-26-22-27-21.png" alt="2020-03-26-22-27-21"></p><p>接下来我们看看它的一个初始化方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 new 一个 hashmap 的时候会发现，<code>Node&lt;K,V&gt;[] table;</code> table 就没有设值。</p><p>然后我么来看一个 put 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">// 开始进行resize()保证桶的容量； </span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="comment">//i = (n - 1) &amp; hash 是不是最后一个桶，并且为null</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">       <span class="comment">//直接加到tab后面</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">//</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">// 进行树化</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总的一个put流程大致就是： 初始化或者 resize() 扩容和树化；</p><p>现在我们看看 resize() 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;<span class="comment">//threshold=capacity * load factor</span></span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//是否超过最大值 MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 2 的 30 次方</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//两倍扩容</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">       <span class="comment">// 桶的容量默认值： DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4； 默认值 16；</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">       <span class="comment">// 桶扩容的阀值：</span></span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//设置扩容的阀值</span></span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">       <span class="comment">//如果原来的桶中不为null，扩容后要把桶中的数据迁移到新桶中。</span></span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                      <span class="comment">// 会讲原来的一个链条打散成两条链</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           <span class="comment">//这里也就是会在高并发下导致hashmap出现问题的原因</span></span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">//这里的 e.hash &amp; oldCap ==0 可以有效避免重复计算hash值，而且把原来的桶中重复的值分散到新的桶中。</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看完 resize 就会发现发现它做了很多事，初始化，扩容，数据复制；数据复制也会造成一定的开销。<br>另外resize中的防止rehash并且分散之前的冲突节点的算法也很巧妙：<br><img src="/images/qiniu/2020-03-27-23-13-43.png" alt="2020-03-27-23-13-43"></p><p>另外我们看下树化：<code>treeifyBin(tab, hash);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="comment">//如果是空桶或者桶里面的数据少于 MIN_TREEIFY_CAPACITY = 64;只是简单扩容就行了。</span></span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                   hd = p;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">               hd.treeify(tab);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>所以可以看到 HashMap 的 <code>LOAD_FACTOR</code> 加载因子和容量是多么的重要了。我们一般的化可以优化为：<br><code>负载因子 * 容量 &gt; 元素数量</code> 即初始化容量时候，值要大于“预估元素数量 / 负载因子” </p><p>hashmap在高并发场景下会发生什么了？<br>要记住，hashmap本身就被声明为了非同步安全的类，如果在多线程环境下是会有可能导致无限循环占用cpu，size不准确，具体的原因可以看下这篇博客 <a href="https://mailinator.blogspot.com/2009/06/beautiful-race-condition.html" target="_blank" rel="noopener">a beatiful race condition</a></p><p>那么问一下，为什么要进行树化了？<br>本质上是个安全问题，如果一个对象hash冲突，都被放到一个桶里面，就会形成一个链表，链表的查询是线性的，就会严重影响存储的性能；<br>另外有种安全攻击叫做“哈希碰撞拒绝服务攻击”，就是构建哈希冲突的数据，恶意代码用这些数据与服务器进行交互，导致服务端cpu大量占用。来达到攻击的目录。</p><p>那么，并发下，我们应该怎么使用HashMap了？<br>明天讲～</p><!--但是假如你在面试，面试官会怎么问你了？咳咳，模拟下：Q：你好，请问你们平常用的jdk版本是多少？A：线上主要用的是jdk8Q：那你能介绍下常见的这个HashMap吗？A：balabla 上面一大段Q：1.8中对hashmap有什么优化了？A：在数据存储中引入了树化，在数据超过8的时候就会变成红黑树。Q：为什么要引入树来做存储了？有什么好处了？Q: 能不能介绍下hashmap put的整个过程？Q: 能不能介绍下hashmap的使用场景？Q：高并发的场景下应该怎么办了？ ## 这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题？## 这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off （要什么不要什么）是什么## 这个技术适用的场景（技术场景或业务场景）## 这个技术的组成部分和关键点（核心思想，核心组件）## 这个技术的底层原理和关键实现## 已有的实现和它之间的对比https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6423457--><p>参考：<a href="https://www.cnblogs.com/Michaelwjw/p/6411176.html" target="_blank" rel="noopener">https://www.cnblogs.com/Michaelwjw/p/6411176.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HashMap-介绍&quot;&gt;&lt;a href=&quot;#HashMap-介绍&quot; class=&quot;headerlink&quot; title=&quot;HashMap 介绍&quot;&gt;&lt;/a&gt;HashMap 介绍&lt;/h1&gt;&lt;p&gt;这个该怎么写了？其实网上好多博客说了这个，其实我看了之后，甚至看了源码之后我也不知道怎么写，源码中Hashmap的介绍大致如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Hashmap 大致是等于hashtable的，除了非同步和允许null值之外；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;不保证数据的顺序；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;常数级别的get和put；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最重要性能的两个属性： capacity  ， loadfactor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0.75的加载因子数是一种空间和时间上的tradeoff（平衡）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;相同的hashcode()会降低它的性能&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hashmap的实现是非同步的；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iterator fail-fast ConcurrentModificationException.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先我们介绍下它的内部数据结构吧。&lt;/p&gt;
&lt;h2 id=&quot;HashMap的内部结构&quot;&gt;&lt;a href=&quot;#HashMap的内部结构&quot; class=&quot;headerlink&quot; title=&quot;HashMap的内部结构&quot;&gt;&lt;/a&gt;HashMap的内部结构&lt;/h2&gt;
    
    </summary>
    
      <category term="Java" scheme="http://chenzhijun.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://chenzhijun.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>查漏补缺 Java 系列 - String，StringBuffer，StringBuilder有什么区别</title>
    <link href="http://chenzhijun.me/2020/03/18/java-string-stringbuffer-stringbuilder/"/>
    <id>http://chenzhijun.me/2020/03/18/java-string-stringbuffer-stringbuilder/</id>
    <published>2020-03-18T15:30:30.000Z</published>
    <updated>2020-05-13T13:33:03.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查漏补缺-Java-系列-String，StringBuffer，StringBuilder有什么区别"><a href="#查漏补缺-Java-系列-String，StringBuffer，StringBuilder有什么区别" class="headerlink" title="查漏补缺 Java 系列 - String，StringBuffer，StringBuilder有什么区别"></a>查漏补缺 Java 系列 - String，StringBuffer，StringBuilder有什么区别</h1><h2 id="String，StringBuffer，StringBuilder-他们三者的优势和劣势？"><a href="#String，StringBuffer，StringBuilder-他们三者的优势和劣势？" class="headerlink" title="String，StringBuffer，StringBuilder 他们三者的优势和劣势？"></a>String，StringBuffer，StringBuilder 他们三者的优势和劣势？</h2><p>一般来说，Java中String是用来对字符串进行操作的类，是一个 Immutable 类，它是被声明为final class，所有的属性也是final的；String中的所有跟字符串修改的方法都是新建了一个String，就会产生很多额外的String对象；</p><p>StringBuffer是一个线程安全的类，它的所有方法都加上了synchronized; StringBuffer还有个优点就是它在执行append的操作的时候将新的字符串插入到原来的串中，可能是末尾，也可能是中间位置；</p><p>StringBuilder 是 Java 1.5 中新增的，它可以看成是StringBuffer的非线程安全实现版本。<br><a id="more"></a></p><h2 id="String，StringBuffer，StringBuilder-三者的使用场景？"><a href="#String，StringBuffer，StringBuilder-三者的使用场景？" class="headerlink" title="String，StringBuffer，StringBuilder 三者的使用场景？"></a>String，StringBuffer，StringBuilder 三者的使用场景？</h2><p>其实在jdk9开始，如果我们javap String相关的源码会发现，不再有之前的StringBuilder出现了。这是因为在新的jdk9中，采用了一种新的方式：COMPACT_STRINGS 。底层的数据结构用的是 一个bytes数组+coder的方式组建String的内容，用coder来判断是用LATIN1,UTF16。那么很明显了。<br>如果你在jdk8里面，需要线程同步安全的化，可以使用StringBuffer；如果涉及到大量的String操作，可以考虑使用StringBuilder；但是我认为这个还是要根据编码来，编码首先是给人看的，一定要保证可读性。比如下列的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">"abc"</span>).append(<span class="string">"def"</span>);<span class="comment">//如果很长了？</span></span><br><span class="line"></span><br><span class="line">String abcdeft=<span class="string">"abc"</span>+<span class="string">"def"</span>;</span><br></pre></td></tr></table></figure><h2 id="三者的关键组成部分和关键点？"><a href="#三者的关键组成部分和关键点？" class="headerlink" title="三者的关键组成部分和关键点？"></a>三者的关键组成部分和关键点？</h2><blockquote><p>ps: jdk8中用的是数组char；jdk9+中用的是数组byte；</p></blockquote><h2 id="三者的底层原理和关键实践"><a href="#三者的底层原理和关键实践" class="headerlink" title="三者的底层原理和关键实践"></a>三者的底层原理和关键实践</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查漏补缺-Java-系列-String，StringBuffer，StringBuilder有什么区别&quot;&gt;&lt;a href=&quot;#查漏补缺-Java-系列-String，StringBuffer，StringBuilder有什么区别&quot; class=&quot;headerlink&quot; title=&quot;查漏补缺 Java 系列 - String，StringBuffer，StringBuilder有什么区别&quot;&gt;&lt;/a&gt;查漏补缺 Java 系列 - String，StringBuffer，StringBuilder有什么区别&lt;/h1&gt;&lt;h2 id=&quot;String，StringBuffer，StringBuilder-他们三者的优势和劣势？&quot;&gt;&lt;a href=&quot;#String，StringBuffer，StringBuilder-他们三者的优势和劣势？&quot; class=&quot;headerlink&quot; title=&quot;String，StringBuffer，StringBuilder 他们三者的优势和劣势？&quot;&gt;&lt;/a&gt;String，StringBuffer，StringBuilder 他们三者的优势和劣势？&lt;/h2&gt;&lt;p&gt;一般来说，Java中String是用来对字符串进行操作的类，是一个 Immutable 类，它是被声明为final class，所有的属性也是final的；String中的所有跟字符串修改的方法都是新建了一个String，就会产生很多额外的String对象；&lt;/p&gt;
&lt;p&gt;StringBuffer是一个线程安全的类，它的所有方法都加上了synchronized; StringBuffer还有个优点就是它在执行append的操作的时候将新的字符串插入到原来的串中，可能是末尾，也可能是中间位置；&lt;/p&gt;
&lt;p&gt;StringBuilder 是 Java 1.5 中新增的，它可以看成是StringBuffer的非线程安全实现版本。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://chenzhijun.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://chenzhijun.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>shell-operation</title>
    <link href="http://chenzhijun.me/2019/12/18/shell-operation/"/>
    <id>http://chenzhijun.me/2019/12/18/shell-operation/</id>
    <published>2019-12-18T14:03:57.000Z</published>
    <updated>2020-05-13T13:33:03.895Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx-http-1.1</title>
    <link href="http://chenzhijun.me/2019/12/18/nginx-http-1-1/"/>
    <id>http://chenzhijun.me/2019/12/18/nginx-http-1-1/</id>
    <published>2019-12-18T13:57:00.000Z</published>
    <updated>2020-05-13T13:33:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-Http-1-1-Host规范"><a href="#Nginx-Http-1-1-Host规范" class="headerlink" title="Nginx Http 1.1 Host规范"></a>Nginx Http 1.1 Host规范</h1><p>最近发现一个异常问题。一个web服务挂载在nginx后端，然后client通过socket连接后，构建成http-post请求，发现最后nginx会直接返回499，发现其实是客户端断链接，其实应该不对。<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_ignore_client_abort</a></p><p>之后的是http1.1的规范。<a href="https://tools.ietf.org/html/rfc2616#section-14.23" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616#section-14.23</a> http1.1中，如果Host为空会直接返回400的状态码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx-Http-1-1-Host规范&quot;&gt;&lt;a href=&quot;#Nginx-Http-1-1-Host规范&quot; class=&quot;headerlink&quot; title=&quot;Nginx Http 1.1 Host规范&quot;&gt;&lt;/a&gt;Nginx Http 1.1 Host规范&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ops 操作手册</title>
    <link href="http://chenzhijun.me/2019/12/01/kubernetes-tips/"/>
    <id>http://chenzhijun.me/2019/12/01/kubernetes-tips/</id>
    <published>2019-12-01T10:09:17.000Z</published>
    <updated>2020-05-13T13:33:03.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="给命令行增加快捷操作提示符"><a href="#给命令行增加快捷操作提示符" class="headerlink" title="给命令行增加快捷操作提示符"></a>给命令行增加快捷操作提示符</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source &lt;(kubectl completion bash) # setup autocomplete in bash into the current shell, bash-completion package should be installed first.echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bashrc # add autocomplete permanently to your bash shell.</span><br><span class="line">alias k=kubectl</span><br><span class="line">complete -F __start_kubectl k</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="快速删除kubernetes资源"><a href="#快速删除kubernetes资源" class="headerlink" title="快速删除kubernetes资源"></a>快速删除kubernetes资源</h2><p>删除Terminating的pods</p><p><code>kubectl get pods --all-namespaces|grep Termi|awk &#39;{print &quot;kubectl -n &quot;$1&quot; delete pods &quot;$2&quot; --force --grace-period=0&quot;}&#39;|xargs -i echo {} &gt;delete.sh</code></p><p>缩容：</p><p><code>kcc scale --current-replicas=3 --replicas=0 deployment/orche</code></p><p>禁止主机调度：</p><p><code>kubectl uncordon NODE_NAME</code></p><p>显示节点ip：</p><p><code>kubectl get nodes -o wide --show-labels|awk &#39;{print $1&quot;\t&quot;$2&quot;\t&quot;$6}&#39;</code></p><p>删除标签：</p><p> <code>kubectl label node cnsz12.company.cn bad-</code></p><p>快速启动一个容器：</p><p> <code>kc run -i --tty --image harbor.com/library/busybox:1.28.4 dns-test --restart=Never --rm /bin/sh</code></p><h2 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https://github.com/buger/goreplay</span><br><span class="line"></span><br><span class="line">./gor --input-raw :8080 --input-raw-track-response --output-stdout</span><br><span class="line"></span><br><span class="line">./gor --input-raw :8080 --output-stdout --http-allow-url RH_SSO/SeqSso.sso</span><br><span class="line"></span><br><span class="line">tcpdump -i eth0 dst host 10.70.1.76 and dst port 4410</span><br></pre></td></tr></table></figure><h2 id="文件底层无法编辑"><a href="#文件底层无法编辑" class="headerlink" title="文件底层无法编辑"></a>文件底层无法编辑</h2><p>chattr</p><h2 id="docker-容器网络工具镜像"><a href="#docker-容器网络工具镜像" class="headerlink" title="docker 容器网络工具镜像"></a>docker 容器网络工具镜像</h2><p><code>docker run -ti --net container:a967 nicolaka/netshoot:latest bash</code></p><!--jdk8u202之后，jvm获取cgroup的内存限制。kubectl get pods --all-namespaces|grep Termi|awk '{print "kubectl -n "$1" delete pods "$2" --force --grace-period=0"}'|xargs -i echo {} >delete.sh网络模型：ovs open vswitch ,daemonset启动openshift本身使用static podfind /sys/fs/cgroup/memory -type d | wc -lThe node was low on resource: memory. Container rdspm-app was using 2159200Ki, which exceeds its request of 0https://www.cnblogs.com/duanxz/p/10247494.htmlhttps://blog.csdn.net/weixin_33744141/article/details/86251459find . -amin -10 # 查找在系统中最后10分钟访问的文件find . -atime -2 # 查找在系统中最后48小时访问的文件find . -empty # 查找在系统中为空的文件或者文件夹find . -group cat # 查找在系统中属于 groupcat的文件find . -mmin -5 # 查找在系统中最后5分钟里修改过的文件find . -mtime -1 #查找在1天以内修改过的文件find . -mtime +7 #查找在7天以外修改过的文件find . -nouser #查找在系统中属于作废用户的文件find . -user fred #查找在系统中属于FRED这个用户的文件find . -type -f # 查找文件类型为普通文件的文件nginx 会话粘贴http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalivehttps://stackoverflow.com/questions/24453388/nginx-reverse-proxy-causing-504-gateway-timeouthttps://superuser.com/questions/1489355/website-shows-a-blank-page-when-opened-from-search-engines-or-href-links-but-wo应用频繁启动，导致k8s node节点not ready100.70.88.44PLEG unhealth   https://github.com/kubernetes/kubernetes/issues/45419https://github.com/kubernetes/kubernetes/issues/61117CREATE USER 'monitor'@'100.69.224.39' IDENTIFIED BY 'monitor1875' WITH MAX_USER_CONNECTIONS 3;GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO 'monitor'@'100.69.224.39';GRANT SELECT ON performance_schema.* TO 'monitor'@'100.69.224.39';go modhaproxy 支持websocketsed -i '/120/d’ known_hosts 替换120的行sed -n ‘/120/p' known_hosts  查找ruby的行git log --graph --pretty=oneline --abbrev-commitControl a 最开始，control e 最末尾nodeport,hostport-->]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;给命令行增加快捷操作提示符&quot;&gt;&lt;a href=&quot;#给命令行增加快捷操作提示符&quot; class=&quot;headerlink&quot; title=&quot;给命令行增加快捷操作提示符&quot;&gt;&lt;/a&gt;给命令行增加快捷操作提示符&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;source &amp;lt;(kubectl completion bash) # setup autocomplete in bash into the current shell, bash-completion package should be installed first.echo &quot;source &amp;lt;(kubectl completion bash)&quot; &amp;gt;&amp;gt; ~/.bashrc # add autocomplete permanently to your bash shell.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias k=kubectl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;complete -F __start_kubectl k&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基础排序算法</title>
    <link href="http://chenzhijun.me/2019/09/13/datastruct-normal-sort-algorithm2/"/>
    <id>http://chenzhijun.me/2019/09/13/datastruct-normal-sort-algorithm2/</id>
    <published>2019-09-13T11:14:07.000Z</published>
    <updated>2020-05-13T13:33:03.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础排序算法2"><a href="#基础排序算法2" class="headerlink" title="基础排序算法2"></a>基础排序算法2</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的意义是将利用递归的思想，将一个大问题解决为可重复求解的小问题，最后合并这些小问题得出结果。<br>归并是直接数组对半分，分成两个子数组。然后对两个子数组再进行排序求解。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序：对半分成两个子数组，然后子数组再向下分，之后合并数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="number">1</span> / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        mergeSort2(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//        mergeSort(a, 0, a.length - 1);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> middle = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        mergeSort2(arr, start, middle);</span><br><span class="line">        mergeSort2(arr, middle + <span class="number">1</span>, end);</span><br><span class="line">        merge2(arr, start, middle, end);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> middle, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用来存储的临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//p q 两个指针，遍历arr</span></span><br><span class="line">        <span class="keyword">int</span> p = start;</span><br><span class="line">        <span class="keyword">int</span> q = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//[0 , middle] 和 [middle+1 , end] 的数据分别赋值给新数组</span></span><br><span class="line">        <span class="keyword">while</span> (p &lt;= middle &amp;&amp; q &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[p] &lt;= arr[q]) &#123;</span><br><span class="line">                newArr[i++] = arr[p++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newArr[i++] = arr[q++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断两边谁还有剩余的数</span></span><br><span class="line">        <span class="comment">//1 假设左边有剩余的数</span></span><br><span class="line">        <span class="keyword">int</span> p1 = p;</span><br><span class="line">        <span class="keyword">int</span> q1 = middle;</span><br><span class="line">        <span class="comment">//2 判断是不是左边真的有剩余，下面的if可以判断出右边是不是有剩余，while中只会有一边清空时才会退出while</span></span><br><span class="line">        <span class="keyword">if</span> (q &lt;= end) &#123;</span><br><span class="line">            p1 = q;</span><br><span class="line">            q1 = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将剩余的数填满新数组</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= q1) &#123;</span><br><span class="line">            newArr[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将新数组（已排序）的值替换老数组的位置</span></span><br><span class="line">        <span class="comment">//这里要注意start-end之间的个数其实就是newArr数组的个数为end-start , 所以这里只能让idx最大为end-start 也相当于为循环end-start次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt;= end - start; idx++) &#123;</span><br><span class="line">            arr[idx + start] = newArr[idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> q = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, start, q);</span><br><span class="line">        mergeSort(arr, q + <span class="number">1</span>, end);</span><br><span class="line">        merge(arr, start, q, end);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> middle, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tmps = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p = start;</span><br><span class="line">        <span class="keyword">int</span> q = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= middle &amp;&amp; q &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[p] &lt;= arr[q]) &#123;</span><br><span class="line">                tmps[i] = arr[p];</span><br><span class="line">                p++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmps[i] = arr[q];</span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i1 = p;</span><br><span class="line">        <span class="keyword">int</span> j1 = middle;</span><br><span class="line">        <span class="keyword">if</span> (q &lt;= end) &#123;</span><br><span class="line">            i1 = q;</span><br><span class="line">            j1 = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i1 &lt;= j1) &#123;</span><br><span class="line">            tmps[i] = arr[i1];</span><br><span class="line">            i1++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= end - start; ++j) &#123;</span><br><span class="line">            arr[start + j] = tmps[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>也是归并排序的一种，不过快排采用的是先分区，再归并。快排采用的是找一个基准点，然后比较数组中数据的基准点找出分割点，以分割点来割分子数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快排序的思想就是,同一个数组,不需要额外的空间,</span></span><br><span class="line"><span class="comment"> * 最重要的部分是找出每个数据的应该放置的位置，这个位置的左边全小于它，右边全大于它，</span></span><br><span class="line"><span class="comment"> * 它是一个分割点，然后依次类推，每个数据都放到一个这样的位置，数组就拍好顺序了。</span></span><br><span class="line"><span class="comment"> * 快排序：O(nlogn)</span></span><br><span class="line"><span class="comment"> * 空间：O(1)</span></span><br><span class="line"><span class="comment"> * 稳定性：不稳定，因为两两交换嘛。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="number">1</span> / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = quickSortN2(arr, start, end);</span><br><span class="line"><span class="comment">//        int n = quickSortN3(arr, start, end);</span></span><br><span class="line">        quickSort(arr, start, n - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, n + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取末尾为参考值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quickSortN2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[end];<span class="comment">//要从尾部取这个参照点</span></span><br><span class="line">        <span class="keyword">int</span> p = start;<span class="comment">//定一个指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = start; q &lt;= end - <span class="number">1</span>; q++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[q] &lt; pivot) &#123;<span class="comment">//将p留在永远大于参考点的第一个位置</span></span><br><span class="line">                swap(arr, p, q);</span><br><span class="line">                p++;<span class="comment">//顺着左移，保持第一个位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**已经遍历完了p的位置，左边是小于参考点的数据，</span></span><br><span class="line"><span class="comment">         右边是大于参考点的数据，p的位置存放参考点，</span></span><br><span class="line"><span class="comment">         该位置就刚好变成了一个分割点。将一个大的分解了两个子问题，</span></span><br><span class="line"><span class="comment">         而子问题也可以重复刚刚的步骤，最后所有的数据都会待在那个最</span></span><br><span class="line"><span class="comment">         合适的位置，最后的顺序也就排列好了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        swap(arr, p, end);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[p];</span><br><span class="line">        arr[p] = arr[q];</span><br><span class="line">        arr[q] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选第一个为参考值。注意返回的p-1的值</span></span><br><span class="line"><span class="comment">     * 比选最后一个值为参考值多了几次+,-的操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quickSortN3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">        <span class="keyword">int</span> p = start + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = start + <span class="number">1</span>; q &lt;= end; q++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[q] &lt; pivot) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[q];</span><br><span class="line">                arr[q] = arr[p];</span><br><span class="line">                arr[p] = temp;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p的位置是大于参考点的,因此要交换p-1的位置</span></span><br><span class="line">        swap(arr, start, p - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> p - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一版本（错误方法）</span></span><br><span class="line"><span class="comment">     * 有bug，当出现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * [8,1,9,12,6,0]  p=0;q=0</span></span><br><span class="line"><span class="comment">     * a: 1,8,9,12,6,0   p=1;q=1</span></span><br><span class="line"><span class="comment">     * b: 1,6,9,12,8,0   p=2;q=4</span></span><br><span class="line"><span class="comment">     * c: 1,6,0,12,8,9   p=3;q=5</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个时候返回p=3,最终的结果肯定不正确。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quickSortN</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">        <span class="keyword">int</span> p = start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = start; q &lt;= end; q++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[q] &lt; pivot) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[q];</span><br><span class="line">                arr[q] = arr[p];</span><br><span class="line">                arr[p] = temp;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        arr[p] = pivot;</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>桶排序的一种特殊方式，数据必须是非负整数。桶排序的方式是将数据最小值和最大值均分为多个桶，把数据放到桶里面，然后依次取出桶中的数据。计数排序的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        countSort(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数排序就是遍历原始数组A找到最大值，然后以（最大值+1）的长度建立一个新数组B</span></span><br><span class="line"><span class="comment">     * 遍历数组A,每遍历A的一个数据a，在B中a的位置就+1；B[a]=B[a]+1</span></span><br><span class="line"><span class="comment">     * 遍历数组B获取B[a]之前[0-a]的所有数据个数，目前A中已经遍历过一次了，A中的数</span></span><br><span class="line"><span class="comment">     * 据在B中对应的下标中都会有值，统计B中a之前的所有个数，这样我们就能知道A中的数</span></span><br><span class="line"><span class="comment">     * 据a在A数组中应该在哪个位置。B遍历完之后，就相当于知道了a和小于a的所有数据的</span></span><br><span class="line"><span class="comment">     * 个数之和。</span></span><br><span class="line"><span class="comment">     * 新建一个数组C,长度和A一致，我们遍历一下A，取出数据A[i],数据A[i]在C中的位置</span></span><br><span class="line"><span class="comment">     * 应该为在数组B[A[i]]的值，即小于或等于数据A[i]的个数，之后将C[B[A[i]]-1]赋值为A[i]；</span></span><br><span class="line"><span class="comment">     * B[A[i]]为个数</span></span><br><span class="line"><span class="comment">     * B[A[i]]-1为数组实际下边，数组从0开始</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrA</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arrA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = arrA[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrA.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrA[i] &gt; max) &#123;</span><br><span class="line">                max = arrA[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arrB = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//第一步是找出相同值的个数，比如数组里面5的数据，有2个，那么newA中第5个位置为2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrA.length; i++) &#123;</span><br><span class="line">            arrB[arrA[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算数组中当前位置的数据有几个，比如数组中5的数据，那么从0-5，总共有多少个数字了？</span></span><br><span class="line">        <span class="comment">// 这个for循环就是计算总共的数字。计算出数字了之后，我们就知道，5在数组中顺序的位置了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arrB.length; i++) &#123;</span><br><span class="line">            arrB[i] = arrB[i] + arrB[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个新数组，长度跟要排序的数组一样，当我们遍历一下要排序数组，取出里面的数据</span></span><br><span class="line">        <span class="comment">//根据取出的值，在newA中下表为值的位置取出个数,就是这个新数组的位置。</span></span><br><span class="line">        <span class="keyword">int</span>[] arrC = <span class="keyword">new</span> <span class="keyword">int</span>[arrA.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrC.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> position = arrB[arrA[i]] - <span class="number">1</span>;<span class="comment">//arrB 里面存储的是个数，在新数组就是位置，减1是因为从0计算嘛，所以减1</span></span><br><span class="line">            arrC[position] = arrA[i];<span class="comment">// position 位置要等于arr[i]，取出了一个值所以就</span></span><br><span class="line">            arrB[arrA[i]]--;<span class="comment">//取出一个数据了，个数就少一个了。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrA.length; i++) &#123;</span><br><span class="line">            arrA[i] = arrC[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="几种基础排序算法比较"><a href="#几种基础排序算法比较" class="headerlink" title="几种基础排序算法比较"></a>几种基础排序算法比较</h2><p><img src="/images/qiniu/2019-09-13-19-14-25.png" alt="几种基础排序算法比较"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础排序算法2&quot;&gt;&lt;a href=&quot;#基础排序算法2&quot; class=&quot;headerlink&quot; title=&quot;基础排序算法2&quot;&gt;&lt;/a&gt;基础排序算法2&lt;/h1&gt;&lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;p&gt;归并排序的意义是将利用递归的思想，将一个大问题解决为可重复求解的小问题，最后合并这些小问题得出结果。&lt;br&gt;归并是直接数组对半分，分成两个子数组。然后对两个子数组再进行排序求解。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://chenzhijun.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://chenzhijun.me/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础排序算法</title>
    <link href="http://chenzhijun.me/2019/09/10/datastruct-normal-sort-algorithm/"/>
    <id>http://chenzhijun.me/2019/09/10/datastruct-normal-sort-algorithm/</id>
    <published>2019-09-10T13:35:29.000Z</published>
    <updated>2020-05-13T13:33:03.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础排序算法"><a href="#基础排序算法" class="headerlink" title="基础排序算法"></a>基础排序算法</h1><p>每次一看算法就是，嗯，看懂了，每次自己写代码就是，嗯？这怎么写？？ 本文将自己理解的冒泡排序，插入排序，选择排序三种做一个总结。</p><a id="more"></a><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序其实很形象，就是每次选最大，或者最小的值，与第一个值交换，逐次冒泡。就像水里面的泡泡，轻的泡泡总会浮起来一样。</p><p>实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubblingSort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"第"</span>+i+<span class="string">"次:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> an : a) &#123;</span><br><span class="line">            System.err.print(an + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有原始数组a,每次冒泡的结果就如下，我们这里选的是从大到小冒泡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">第0次:</span><br><span class="line">12157935</span><br><span class="line">第1次:</span><br><span class="line">12915735</span><br><span class="line">第2次:</span><br><span class="line">12971535</span><br><span class="line">第3次:</span><br><span class="line">12975135</span><br><span class="line">第4次:</span><br><span class="line">12975513</span><br><span class="line">第5次:</span><br><span class="line">12975531</span><br><span class="line">第6次:</span><br><span class="line">12975531</span><br></pre></td></tr></table></figure><p>冒泡排序的时间复杂度为O(n^2) ; 空间复杂度为O(1);是一个稳定算法。</p><blockquote><p>稳定的意义是指，两个相同的数据，它们排序完之后相对位置不变，比如上面数组的5[a],5[b],排序完之后不会出现5[b],5[a]; a,b为他们的相对位置。</p></blockquote><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的意思就是有一个数组，你可以假定左边的部分是有序的，这个时候你从右边无序的数据中，找出一个，然后将其插入到有序数据的数组中。<br>有点类似打扑克，如果一次性将牌发完，你总得给牌排个序吧，比如从左到右，左边第一张你可以假设这一张是有序的，从第二张开始，你就比较一下第二张和第一张谁大，小的就往前面移动，大的就往后面移动。如果是第三张，依次与第二张比，比完再与第一张比。所以第n张就是与n-1比，再与n-2,n-3，…比较，一直比到有一张比它小的，那么这个时候，就位置就对了。看起来就像是我们将第n张牌，插入到了之前有序的一个数组中。</p><p>算法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] b = insertSort(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</span><br><span class="line">        System.out.print(i + <span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"第"</span> + i + <span class="string">"次,"</span> + <span class="string">"arr[i]为:"</span> + arr[i] + <span class="string">" :"</span>);</span><br><span class="line">        printArr(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printArr(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">第1次,arr[i]为:7 :</span><br><span class="line">17591235</span><br><span class="line">17591235</span><br><span class="line">第2次,arr[i]为:5 :</span><br><span class="line">17591235</span><br><span class="line">15791235</span><br><span class="line">第3次,arr[i]为:9 :</span><br><span class="line">15791235</span><br><span class="line">15791235</span><br><span class="line">第4次,arr[i]为:12 :</span><br><span class="line">15791235</span><br><span class="line">15791235</span><br><span class="line">第5次,arr[i]为:3 :</span><br><span class="line">15791235</span><br><span class="line">13579125</span><br><span class="line">第6次,arr[i]为:5 :</span><br><span class="line">13579125</span><br><span class="line">13557912</span><br></pre></td></tr></table></figure><p>插入牌的时间复杂度为：O(n^2), 空间复杂度为O(1), 是一个稳定排序算法。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序其实就是你拿了一手牌，每次你扫描一遍，拿到最小的那张，把它跟第一张交换下位置。第一次交换第一张位置的，第二次交换第二张位置的，之后依次交换到最后一张。这个咋一看挺像冒泡的，但是远离不相同，冒泡是每次都会有顺移的操作，比如<code>2,3,4,5,1</code>；如果你选了1，它要跟5做比较，交换：<code>2,3,4,1,5</code>；跟4做比较，交换<code>2,3,1,4,5</code>。而选择排序则是：<code>2,3,4,5,1</code>；你先选最小的1，然后跟第一个位置的2做交换变成了<code>1,3,4,5,2</code>,有没有发现，其实只做了一次交换。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] b = selectSort(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</span><br><span class="line">        System.out.print(i + <span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;<span class="comment">//初始化j的位置</span></span><br><span class="line">        <span class="keyword">int</span> k = j;<span class="comment">//数组中值最小的数的位置</span></span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];<span class="comment">//用来存储每次遍历的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (; j &lt; arr.length; j++) &#123;<span class="comment">//遍历数组从i开始，0-i之间的数据可以当做是已经选择了最小的有序数组</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; tmp) &#123;</span><br><span class="line">                tmp = arr[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[k] = arr[i];<span class="comment">//交换当前i的位置和最小值的位置k两个数据</span></span><br><span class="line">        arr[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序算法的时间复杂度为：O(n^2);空间复杂度为：O(1); 稳定性为：不稳定。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础排序算法&quot;&gt;&lt;a href=&quot;#基础排序算法&quot; class=&quot;headerlink&quot; title=&quot;基础排序算法&quot;&gt;&lt;/a&gt;基础排序算法&lt;/h1&gt;&lt;p&gt;每次一看算法就是，嗯，看懂了，每次自己写代码就是，嗯？这怎么写？？ 本文将自己理解的冒泡排序，插入排序，选择排序三种做一个总结。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://chenzhijun.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://chenzhijun.me/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构单链表的一些简单操作</title>
    <link href="http://chenzhijun.me/2019/09/09/datastruct-list-normal-action/"/>
    <id>http://chenzhijun.me/2019/09/09/datastruct-list-normal-action/</id>
    <published>2019-09-09T12:42:20.000Z</published>
    <updated>2020-05-13T13:33:03.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构单链表的一些简单操作"><a href="#数据结构单链表的一些简单操作" class="headerlink" title="数据结构单链表的一些简单操作"></a>数据结构单链表的一些简单操作</h1><p>Node的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node nextNode;</span><br><span class="line">    <span class="keyword">private</span> T v;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node nextNode, T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextNode = nextNode;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextNode</span><span class="params">(Node nextNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextNode = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setV</span><span class="params">(T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllNode</span><span class="params">()</span> </span>&#123;<span class="comment">//我这里是有一个headNode不做数据存储</span></span><br><span class="line">        Node tmpN = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmpN.getNextNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(tmpN.getNextNode().getV());</span><br><span class="line">            System.out.print((tmpN.getNextNode().getNextNode() == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">","</span>));</span><br><span class="line">            tmpN = tmpN.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>平常一条链表大多是<code>a-&gt;b-&gt;c-&gt;d</code>;链表反转后为:<code>a&lt;-b&lt;-c&lt;-d</code>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.gk_time_datastruct.chapter7;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node();</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node();</span><br><span class="line">            newNode.setV(i);</span><br><span class="line">            tmp.setNextNode(newNode);</span><br><span class="line">            tmp = tmp.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">        head.printAllNode();</span><br><span class="line">        System.out.println();</span><br><span class="line">        Node node = reverseNode(head);</span><br><span class="line">        node.printAllNode();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表实际的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">reverseNode</span><span class="params">(Node pHead)</span> </span>&#123;</span><br><span class="line">        Node prev = <span class="keyword">null</span>;</span><br><span class="line">        Node pNode = pHead.getNextNode();</span><br><span class="line">        <span class="keyword">while</span> (pNode!= <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = pNode.getNextNode();</span><br><span class="line">            pNode.setNextNode(prev);</span><br><span class="line">            prev = pNode;</span><br><span class="line">            pNode = next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node reverseNode = <span class="keyword">new</span> Node();</span><br><span class="line">        reverseNode.setNextNode(prev);</span><br><span class="line">        <span class="keyword">return</span> reverseNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先用<code>prev</code>，<code>pNode</code>作两个指针，prev 指的是前一个node，pNode 是指当前node。可以这样理解，pNode指向链表遍历时的当前node，prev指向pNode的链条中前一个节点。</p><p>我们先用一个临时变量<code>next</code>存储当前pNode的下一个节点位置，然后将当前pNode的位置反转，设置为prev的位置，然后prev移动到pNode的位置上，这样pNode的这个位置就存在了prev，所以pNode可以继续向下遍历节点，而我们之前刚好将pNode的下一个节点存储在了next临时变量中，所以有 pNode=next ；一直遍历到pNode为null，说明链表已经遍历完了。这时如果不喜欢头节点就可以直接返回prev，如果喜欢设置头节点，就可以new一个新节点，然后将nextNode设置为prev。这样一条新的链就完成了，链表就被反转了。</p><p>一开始初始化，普通链表：</p><p><img src="/images/qiniu/2019-09-09-20-04-33.png" alt="2019-09-09-20-04-33"></p><p>之后我们开始做操作，先获取0-next节点位置，然后将1-nextNode指向prev所指向的位置，之后2-prev指向pNode所指向的位置，之后3-pNode指向next。</p><p><img src="/images/qiniu/2019-09-09-20-15-02.png" alt="2019-09-09-20-15-02"></p><p>这样一直循环后，我们就可以实际得到一个反转如下的链表：</p><p><img src="/images/qiniu/2019-09-09-20-20-10.png" alt="2019-09-09-20-20-10"></p><p>可以看到，其实如果直接返回prev就已经是一个反转链表了。</p><p>复杂度分析：</p><p>时间复杂度：O(n)，取决与链表长度；</p><p>空间复杂度：O(1)，只新建了pNode,next,prev指针变量,没有额外空间的；</p><h2 id="两个排序链表的合并"><a href="#两个排序链表的合并" class="headerlink" title="两个排序链表的合并"></a>两个排序链表的合并</h2><p>链表的操作中还有一个是假设两个有序链表的合并，如果[1,3,5],[2,4,6,7]合并为[1,2,3,4,5,6,7]，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">mergeNode1AndNode2</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node();</span><br><span class="line">        Node head = node;</span><br><span class="line">        Node tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>) head1.getV() &lt; (<span class="keyword">int</span>) head2.getV()) &#123;</span><br><span class="line">                tmp = head1;</span><br><span class="line">                head1 = head1.getNextNode();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp = head2;</span><br><span class="line">                head2 = head2.getNextNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node.setNextNode(tmp);</span><br><span class="line">            node = node.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        if (head1 != null) &#123;</span></span><br><span class="line"><span class="comment">//            node.setNextNode(head1);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if (head2 != null) &#123;</span></span><br><span class="line"><span class="comment">//            node.setNextNode(head2);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        node.setNextNode(head1 != <span class="keyword">null</span> ? head1 : head2);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们肯定都是要循环链表的，那么循环到一个链表为空的时候，将另一个链表的值加进来即可。</p><p>如<code>while (head1 != null &amp;&amp; head2 != null)</code>这里就是判断链表1和链表2两者看是否为空。如果有一个为空的条件，就退出循环。</p><p>你可能看到<code>node.setNextNode(head1 != null ? head1 : head2);</code>这句话的作用其实就是说，如果head1不为空，那我们就将head1加入到设置为nextNode，反之就是head2。</p><p>合并两个列表的关键点在于，一个要判断两个链表是否为空，这是退出链表循环的条件。（当然如果是个循环链表，这里可能就得改一下了）。另外就是，当链表退出后，要记得将另一个非空链表的剩余值加入到新链中，保证不丢值。</p><h2 id="删除链表倒数第-n-个结点"><a href="#删除链表倒数第-n-个结点" class="headerlink" title="删除链表倒数第 n 个结点"></a>删除链表倒数第 n 个结点</h2><p>有一个链表，然后需要删除链表的倒数第n个位置的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除倒数第n个位置的node</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">removeNode</span><span class="params">(Node node, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span> || node.getNextNode() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"i为0或者node为空，不改动，i从1开始"</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node tmp = node;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tmp = tmp.getNextNode();</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//长度不够</span></span><br><span class="line">            System.out.println(<span class="string">"node长度不够,不改动"</span>);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    Node n0 = node;</span><br><span class="line">    Node n1 = node;</span><br><span class="line">    <span class="comment">//两个指针，一个先走i步，另一个再开始走</span></span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tmp = tmp.getNextNode();</span><br><span class="line">        n0 = n1;</span><br><span class="line">        n1 = n1.getNextNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n0.setNextNode(n1.getNextNode());</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表中间节点"><a href="#链表中间节点" class="headerlink" title="链表中间节点"></a>链表中间节点</h2><p>计算链表中间节点位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">computeNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node quick = head.getNextNode();</span><br><span class="line">    Node slow = head.getNextNode();</span><br><span class="line">    <span class="keyword">while</span> (quick != <span class="keyword">null</span> &amp;&amp; quick.getNextNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.getNextNode();</span><br><span class="line">        quick = quick.getNextNode().getNextNode();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(slow.getV());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="是否为循环链表"><a href="#是否为循环链表" class="headerlink" title="是否为循环链表"></a>是否为循环链表</h2><p>判断一个链表是否为循环链表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCycleList2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Set&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.add(head);</span><br><span class="line">            head = head.getNextNode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCycleList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node n1 = head;</span><br><span class="line">    Node n2 = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="keyword">null</span> &amp;&amp; n2.getNextNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n1 = n1.getNextNode();</span><br><span class="line">        n2 = n2.getNextNode().getNextNode();</span><br><span class="line">        <span class="keyword">if</span> (n1 == n2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构单链表的一些简单操作&quot;&gt;&lt;a href=&quot;#数据结构单链表的一些简单操作&quot; class=&quot;headerlink&quot; title=&quot;数据结构单链表的一些简单操作&quot;&gt;&lt;/a&gt;数据结构单链表的一些简单操作&lt;/h1&gt;&lt;p&gt;Node的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Node nextNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; T v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T v)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.v = v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Node nextNode, T v)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.nextNode = nextNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.v = v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Node &lt;span class=&quot;title&quot;&gt;getNextNode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nextNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setNextNode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Node nextNode)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.nextNode = nextNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;getV&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setV&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T v)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.v = v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printAllNode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//我这里是有一个headNode不做数据存储&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node tmpN = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (tmpN.getNextNode() != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.print(tmpN.getNextNode().getV());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.print((tmpN.getNextNode().getNextNode() == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tmpN = tmpN.getNextNode();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://chenzhijun.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://chenzhijun.me/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>shell 相关基本操作</title>
    <link href="http://chenzhijun.me/2019/09/07/shell-learn-1/"/>
    <id>http://chenzhijun.me/2019/09/07/shell-learn-1/</id>
    <published>2019-09-07T04:50:53.000Z</published>
    <updated>2020-05-13T13:33:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shell-相关基本操作"><a href="#shell-相关基本操作" class="headerlink" title="shell 相关基本操作"></a>shell 相关基本操作</h1><h2 id="shell-基础"><a href="#shell-基础" class="headerlink" title="shell 基础"></a>shell 基础</h2><p>shell中的脚本通常就是控制台中的语句，将这些语句结合到一个文件中，就组成了脚本。脚本的第一行通常是<code>#!/bin/bash</code>开通，这行的作用是指定用哪个shell。可以<code>cat /etc/shells</code>查看当前操作系统支持哪些shell。</p><p>在控制台中我们使用 <code>;</code> 隔开多条语句，在shell脚本中则是一行命令独立一行。通常我们会以<code>*.sh</code>结尾来作为一个脚本名称，另外会将其权限设置为可执行权限：<code>chmod u+x *.sh</code>。</p><a id="more"></a><h2 id="管道与重定向"><a href="#管道与重定向" class="headerlink" title="管道与重定向"></a>管道与重定向</h2><p>管道的符号是：<code>|</code>，作用是将前一个命令的操作结果传给第二个命令：<code>ps | cat</code>，<code>echo 123 | ps</code></p><p>重定向的符号:</p><p>1: 输入重定向：<code>&lt;</code>;<br>2：输出重定向<code>&gt;</code>,<code>&gt;&gt;</code>,<code>2&gt;</code>,<code>&amp;&gt;</code>;</p><p>输入输出组合使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /path/to/a/file &lt;&lt; EOF</span><br><span class="line">I am test</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><code>&gt;</code> : 先会清空文件然后再输出到文件</p><p><code>&gt;&gt;</code> ：追加到文件中，会在最后一行添加</p><p><code>2&gt;</code> ：如果出现异常，将异常结果输出到文件中</p><p><img src="/images/qiniu/2019-09-07-11-36-12.png" alt="2019-09-07-11-36-12"></p><p><code>&amp;&gt;</code> : 不管结果对错都输入到文件中</p><p><img src="/images/qiniu/2019-09-07-11-41-02.png" alt="2019-09-07-11-41-02"></p><h2 id="shell-脚本执行的几种方式"><a href="#shell-脚本执行的几种方式" class="headerlink" title="shell 脚本执行的几种方式"></a>shell 脚本执行的几种方式</h2><p><code>bash xxx.sh</code> : 开了一个子进程bash执行脚本，可以不需要shell文件有可执行权限，就可以执行脚本；</p><p><code>./xxx.sh</code> ：同bash，不过需要脚本有可执行权限；</p><p><code>source xxx.sh</code> ：在当前shell内去执行脚本，脚本可以没有可执行权限；</p><p><code>. xxx.sh</code> ：source的缩写；</p><p><img src="/images/qiniu/2019-09-07-11-53-42.png" alt="2019-09-07-11-53-42"></p><h2 id="变量定义与使用"><a href="#变量定义与使用" class="headerlink" title="变量定义与使用"></a>变量定义与使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME=chenzhijun</span><br><span class="line">echo $NAME</span><br></pre></td></tr></table></figure><p>上面中<code>=</code>两边不能有空格，不然的话会将 NAME 识别成一个命令来报错。使用变量 NAME 的时候只需要带上<code>$</code>即可。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p><code>env</code> <code>set</code> 获取环境变量；</p><p><code>$PS1</code>可以修改总端显示</p><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p><code>$?</code> : 使用<code>echo $?</code>可以获取上一条命令执行的结果，成功为0，失败为1</p><p><code>$$</code> ：获取当前的pid</p><p><code>$0</code> ：当前进程名称</p><p><img src="/images/qiniu/2019-09-07-12-15-44.png" alt="2019-09-07-12-15-44"></p><p>执行的方式不同，<code>$0</code>的值也不同。</p><h3 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span>/bin/bash</span><br><span class="line"><span class="meta">#</span> $1 $2 ...$9 $&#123;10&#125;</span><br><span class="line"></span><br><span class="line">pos1=$1</span><br><span class="line">pos2=$&#123;2-_&#125; # 如果$2为空值，用`_`代替</span><br></pre></td></tr></table></figure><h3 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/etc/profile</span><br><span class="line">/etc/profile.d/</span><br><span class="line"></span><br><span class="line">~/.bash_profile</span><br><span class="line">~/.bashrc</span><br><span class="line"></span><br><span class="line">/etc/bashrc</span><br></pre></td></tr></table></figure><p><code>/etc/profile*</code> 是所有用户通用的。<code>~/.bash*</code>是用户特有的。 </p><p>用户登录分为<code>login shell</code>，<code>nologin shell</code> 。如果是<code>su - user</code>是<code>login-shell</code> ，如果是<code>su user</code>是<code>nologin shell</code></p><p>如果在每个文件第一行加入<code>echo xxx</code>，可以看到如下加载顺序：</p><p><img src="/images/qiniu/2019-09-07-12-34-30.png" alt="2019-09-07-12-34-30"></p><p>要注意作用域的问题，shell执行的时候通常是一个subshell，也就是一个子进程shell，要注意变量是否可以传递过去。一般可以用<code>source /etc/profile</code>来重加载；也使用export也可以将当前shell的变量传递subshell中。</p><p><img src="/images/qiniu/2019-09-07-12-39-06.png" alt="2019-09-07-12-39-06"></p><p>上面的方式是在<code>/etc/profile</code>文件最后面增加了<code>aaa</code>变量，使用source可以加载到当前shell中，使用export可以在subshell（bash命令）也同样获取到<code>aaa</code>的值。</p><h2 id="常用的一些脚本命令"><a href="#常用的一些脚本命令" class="headerlink" title="常用的一些脚本命令"></a>常用的一些脚本命令</h2><ol><li>找出dir目录下文件名带 <code>xxx</code> 的文件 : <code>find /dir -name *xxx*</code> ; </li><li>找出dir目录下文件中带 <code>xxx</code> 内容的文件 ：<code>grep -r &quot;xxx&quot; /dir</code> ;</li><li>找出dir目录下文件名带 <code>aaa</code> 的文件并且文件路径中有 <code>bbb</code> 然后查找这些文件中含有 <code>ccc</code> 的文件，替换这些文件中的 <code>ddd</code> 为 <code>eee</code>: <code>find /dir -name &quot;*aaa*&quot;|grep &#39;bbb&#39;|xargs grep &#39;ccc&#39; -l|xargs sed -i &#39;s/ddd/eee/g&#39;</code> ;<br><code>grep -l</code> 为输出全路径。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/dylanaraps/pure-bash-bible" target="_blank" rel="noopener">github shell 大全</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;shell-相关基本操作&quot;&gt;&lt;a href=&quot;#shell-相关基本操作&quot; class=&quot;headerlink&quot; title=&quot;shell 相关基本操作&quot;&gt;&lt;/a&gt;shell 相关基本操作&lt;/h1&gt;&lt;h2 id=&quot;shell-基础&quot;&gt;&lt;a href=&quot;#shell-基础&quot; class=&quot;headerlink&quot; title=&quot;shell 基础&quot;&gt;&lt;/a&gt;shell 基础&lt;/h2&gt;&lt;p&gt;shell中的脚本通常就是控制台中的语句，将这些语句结合到一个文件中，就组成了脚本。脚本的第一行通常是&lt;code&gt;#!/bin/bash&lt;/code&gt;开通，这行的作用是指定用哪个shell。可以&lt;code&gt;cat /etc/shells&lt;/code&gt;查看当前操作系统支持哪些shell。&lt;/p&gt;
&lt;p&gt;在控制台中我们使用 &lt;code&gt;;&lt;/code&gt; 隔开多条语句，在shell脚本中则是一行命令独立一行。通常我们会以&lt;code&gt;*.sh&lt;/code&gt;结尾来作为一个脚本名称，另外会将其权限设置为可执行权限：&lt;code&gt;chmod u+x *.sh&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://chenzhijun.me/categories/Linux/"/>
    
    
      <category term="shell" scheme="http://chenzhijun.me/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>golang 并发基础（二）</title>
    <link href="http://chenzhijun.me/2019/08/25/golang-goroutine2/"/>
    <id>http://chenzhijun.me/2019/08/25/golang-goroutine2/</id>
    <published>2019-08-25T14:49:36.000Z</published>
    <updated>2020-05-13T13:33:03.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="golang-并发基础（二）"><a href="#golang-并发基础（二）" class="headerlink" title="golang 并发基础（二）"></a>golang 并发基础（二）</h1><p>上一篇简单介绍了并发与并行，goroutine实际工作的原理示意图，现在我们来看下golang是怎么处理并发中竞争状态的。</p><p>竞争状态：如果两个或多个goroutine在没有同步的情况下对同一个资源进行读写操作，就处于相互竞争的状态，称为竞争状态。对一个共享资源的操作必须是<strong>原子化</strong>的，即同一时刻只能由一个goroutine对共享资源进行读和写操作。<br><a id="more"></a></p><h2 id="同步操作方式–锁住共享资源"><a href="#同步操作方式–锁住共享资源" class="headerlink" title="同步操作方式–锁住共享资源"></a>同步操作方式–锁住共享资源</h2><p>golang提供atomic和sync包，两个包里的函数提供了很好的解决方案。</p><h3 id="原子函数-atomic-包"><a href="#原子函数-atomic-包" class="headerlink" title="原子函数 atomic 包"></a>原子函数 atomic 包</h3><p>我们可以看一下atomic提供的原子函数，它提供底层加锁的方式来同步访问整形变量和指针，示例代码:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">counter <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Final Counter:"</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">atomic.AddInt64(&amp;counter, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥锁-mutex"><a href="#互斥锁-mutex" class="headerlink" title="互斥锁 mutex"></a>互斥锁 mutex</h3><p>使用互斥锁也是一种同步访问共享资源的方式，互斥的概念就是AB只有一个可以访问，要不就是A，要不就是B。相当于一张门，只能一个人进入，第一个进入的人就把门锁了，其它人都不可以进来，只有等这个人把锁打开了，其它人才能重新竞争锁。</p><p>看一下代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">"Final Counter: %d\n"</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">mutex.Lock() <span class="comment">//锁住</span></span><br><span class="line">&#123;</span><br><span class="line">value := counter</span><br><span class="line"></span><br><span class="line">runtime.Gosched()</span><br><span class="line"></span><br><span class="line">value++</span><br><span class="line"></span><br><span class="line">counter = value</span><br><span class="line">&#125;</span><br><span class="line">mutex.Unlock()<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道-channel"><a href="#通道-channel" class="headerlink" title="通道 channel"></a>通道 channel</h3><p>在goroutine之间还可以通过通道来发送和接受需要共享的资源，在goroutine之间做同步。当一个资源需要被goroutine共享时，通道在goroutine之间架起了一个管道，并提供了确保同步交换数据的机制。声明通道，需要指定被共享的数据类型。go中需要使用内置函数make来创建一个通道。</p><p>通道的类型由两种：无缓冲通道与有缓冲通道。定义的方式如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//无缓冲</span></span><br><span class="line">unbuffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有缓冲 </span></span><br><span class="line">buffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>通道的赋值和取值如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">buffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">buffered &lt;- <span class="string">"ok, set channel value"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line">value := &lt;- buffered</span><br></pre></td></tr></table></figure><p>无缓冲通道就像“接力跑步赛”，数据就是那个“接力棒”，通道就是两个运动员之间的跑道。如果运动员A拿到接力棒，不将接力棒传到运动员B的手中，那么B就无法开始跑（阻塞），而A因为B没有拿到接力棒，A也无法去做其它的事情。所以A其实也是阻塞在了传递的这个过程中。可以看到传递“接力棒”和接受“接力棒”这两个过程其实是个同步的，两个都无法独立存在。</p><p>有缓存通道就像是吃转转火锅，通道就是传送带，数据就是传送带上的每碟食物，goroutine就是厨师和顾客。缓冲数量就是传送带可以放的碟子数量。所以一个厨师(goroutine)将餐碟放到传送带上，传送带本身就只能存放固定数量的餐碟，也就是缓冲带。如果缓冲带满了，那么厨师只能等待着，等到某个餐碟空了，再放食物。而顾客也是从传送带上取餐碟，只要传送带上面有餐碟，就会吃么。如果顾客拿到手中的餐碟没吃完，传送带上还有空位，那么厨师可以继续放，如果没有空位了，就只能等顾客，吃完再从传送带上取出餐碟，这样才能继续。</p><p>两者的区别：无缓冲通道保证接受和发送的goroutine会在同一时间进行数据交换；有缓冲通道就不提供这种保证。</p><p>要注意通道的关闭操作，当通道关闭后，goroutine依旧可以从通道接收数据，但是不能再往里面发送数据了。从通道获取数据的时候会返回一个ok标志，如果值为false，那说明通道已经关闭了。</p><p>看一下示例。</p><p>无缓冲通道：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This sample program demonstrates how to use an unbuffered</span></span><br><span class="line"><span class="comment">// channel to simulate a relay race between four goroutines.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// wg is used to wait for the program to finish.</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for all Go programs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Create an unbuffered channel.</span></span><br><span class="line">baton := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a count of one for the last runner.</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// First runner to his mark.</span></span><br><span class="line"><span class="keyword">go</span> Runner(baton)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the race.</span></span><br><span class="line">baton &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for the race to finish.</span></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runner simulates a person running in the relay race.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Runner</span><span class="params">(baton <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> newRunner <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait to receive the baton.</span></span><br><span class="line">runner := &lt;-baton</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start running around the track.</span></span><br><span class="line">fmt.Printf(<span class="string">"Runner %d Running With Baton\n"</span>, runner)</span><br><span class="line"></span><br><span class="line"><span class="comment">// New runner to the line.</span></span><br><span class="line"><span class="keyword">if</span> runner != <span class="number">2</span> &#123;</span><br><span class="line">newRunner = runner + <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">"Runner %d To The Line\n"</span>, newRunner)</span><br><span class="line"><span class="keyword">go</span> Runner(baton)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Running around the track.</span></span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is the race over.</span></span><br><span class="line"><span class="keyword">if</span> runner == <span class="number">2</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Runner %d Finished, Race Over\n"</span>, runner)</span><br><span class="line">wg.Done()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exchange the baton for the next runner.</span></span><br><span class="line">fmt.Printf(<span class="string">"Runner %d Exchange With Runner %d\n"</span>,</span><br><span class="line">runner,</span><br><span class="line">newRunner)</span><br><span class="line"></span><br><span class="line">baton &lt;- newRunner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有缓冲通道：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This sample program demonstrates how to use a buffered</span></span><br><span class="line"><span class="comment">// channel to work on multiple tasks with a predefined number</span></span><br><span class="line"><span class="comment">// of goroutines.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">numberGoroutines = <span class="number">4</span>  <span class="comment">// Number of goroutines to use.</span></span><br><span class="line">taskLoad         = <span class="number">10</span> <span class="comment">// Amount of work to process.</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// wg is used to wait for the program to finish.</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// init is called to initialize the package by the</span></span><br><span class="line"><span class="comment">// Go runtime prior to any other code being executed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Seed the random number generator.</span></span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main is the entry point for all Go programs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Create a buffered channel to manage the task load.</span></span><br><span class="line">tasks := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, taskLoad)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Launch goroutines to handle the work.</span></span><br><span class="line">wg.Add(numberGoroutines)</span><br><span class="line"><span class="keyword">for</span> gr := <span class="number">1</span>; gr &lt;= numberGoroutines; gr++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(tasks, gr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a bunch of work to get done.</span></span><br><span class="line"><span class="keyword">for</span> post := <span class="number">1</span>; post &lt;= taskLoad; post++ &#123;</span><br><span class="line">tasks &lt;- fmt.Sprintf(<span class="string">"Task : %d"</span>, post)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close the channel so the goroutines will quit</span></span><br><span class="line"><span class="comment">// when all the work is done.</span></span><br><span class="line"><span class="built_in">close</span>(tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for all the work to get done.</span></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker is launched as a goroutine to process work from</span></span><br><span class="line"><span class="comment">// the buffered channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(tasks <span class="keyword">chan</span> <span class="keyword">string</span>, worker <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// Report that we just returned.</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// Wait for work to be assigned.</span></span><br><span class="line">task, ok := &lt;-tasks</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// This means the channel is empty and closed.</span></span><br><span class="line">fmt.Printf(<span class="string">"Worker: %d : Shutting Down\n"</span>, worker)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Display we are starting the work.</span></span><br><span class="line">fmt.Printf(<span class="string">"Worker: %d : Started %s\n"</span>, worker, task)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Randomly wait to simulate work time.</span></span><br><span class="line">sleep := rand.Int63n(<span class="number">100</span>)</span><br><span class="line">time.Sleep(time.Duration(sleep) * time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Display we finished the work.</span></span><br><span class="line">fmt.Printf(<span class="string">"Worker: %d : Completed %s\n"</span>, worker, task)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>提到goroutine的channel，通常都会与select一起使用。官网的说明：<a href="https://golang.google.cn/ref/spec#Select_statements" target="_blank" rel="noopener">select</a>。简单的说一下select的用法：<br>1：select 的case一定是一个chan的表达式<br>2：select监听的是当前运行的goroutine，如果当前没有运行的goroutine会直接抛出panic；<br>3：如果没有default语句，而多个case都可以执行，那么随机取一个；<br>4：如果有default语句，且case多个可以执行，执行default</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chann</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>, stopCh <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line"><span class="comment">//for &#123;</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="comment">//ch &lt;- i</span></span><br><span class="line"><span class="comment">//fmt.Println(i)</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stopCh &lt;- <span class="literal">true</span></span><br><span class="line">fmt.Println(<span class="string">"ok"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestChan</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">c := <span class="number">0</span></span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> Chann(ch, stopCh)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- <span class="number">10</span>:</span><br><span class="line">fmt.Println(<span class="string">"ok"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line">fmt.Println(<span class="string">"Recvice c1"</span>, c)</span><br><span class="line">fmt.Println(<span class="string">"channel"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line">fmt.Println(<span class="string">"Receive s"</span>, ch)</span><br><span class="line"><span class="comment">//case _ = &lt;-stopCh:</span></span><br><span class="line"><span class="comment">//fmt.Println("stop")</span></span><br><span class="line"><span class="comment">//goto end</span></span><br><span class="line"><span class="comment">//default:</span></span><br><span class="line"><span class="comment">//fmt.Println("default")</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//end:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;golang-并发基础（二）&quot;&gt;&lt;a href=&quot;#golang-并发基础（二）&quot; class=&quot;headerlink&quot; title=&quot;golang 并发基础（二）&quot;&gt;&lt;/a&gt;golang 并发基础（二）&lt;/h1&gt;&lt;p&gt;上一篇简单介绍了并发与并行，goroutine实际工作的原理示意图，现在我们来看下golang是怎么处理并发中竞争状态的。&lt;/p&gt;
&lt;p&gt;竞争状态：如果两个或多个goroutine在没有同步的情况下对同一个资源进行读写操作，就处于相互竞争的状态，称为竞争状态。对一个共享资源的操作必须是&lt;strong&gt;原子化&lt;/strong&gt;的，即同一时刻只能由一个goroutine对共享资源进行读和写操作。&lt;br&gt;
    
    </summary>
    
      <category term="并发" scheme="http://chenzhijun.me/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="golang" scheme="http://chenzhijun.me/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang 并发基础（一）</title>
    <link href="http://chenzhijun.me/2019/08/25/golang-goroutine1/"/>
    <id>http://chenzhijun.me/2019/08/25/golang-goroutine1/</id>
    <published>2019-08-25T12:40:13.000Z</published>
    <updated>2020-05-13T13:33:03.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="golang-并发基础（一）"><a href="#golang-并发基础（一）" class="headerlink" title="golang 并发基础（一）"></a>golang 并发基础（一）</h1><p>golang 在语言的语法和运行时方面内置了对并发的支持。在了解golang的并发之前，我们先看一下操作系统的两个概念：线程和进程。你应该知道，在系统中运行一个程序，其实就是启动了一个进程，而要运行起来，对外来说肯定是需要资源的，比如cpu，内存空间，文件句柄，线程等等..每个进程至少有一个线程，每个进程的初始线程被称为主线程。了解到这些，你大概可以类比一下，比如你创建一个项目，肯定要有main方法（主线程），你的项目中可能还有不同的业务逻辑，这个时候就可以让主进程创建多个线程去运行求结果。线程可以共享进程的空间。另外我们要知道，cpu的执行方式是轮询时间分片的，也就是可能这个线程有10ms的cpu执行时间，所以如果是单核cpu，就是每个线程执行一会，抢占式执行。并发(concurrency)不是并行(parallelism)。并行是在相同的时候让不同的代码都能在不同的处理器上执行，也就是同时做很多事情。并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。<br><a id="more"></a></p><h2 id="并发通信模型"><a href="#并发通信模型" class="headerlink" title="并发通信模型"></a>并发通信模型</h2><p>golang 采用的并发同步模型为通信顺序进程（Communicating Sequential Process,CSP)的模型，通过在goroutine之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。并发通信模型还有一种是Actor，比较著名的例子就是akka.io。</p><h2 id="golang-并发工作模式"><a href="#golang-并发工作模式" class="headerlink" title="golang 并发工作模式"></a>golang 并发工作模式</h2><p>操作系统会在物理处理器上调度线程来运行，而Go语言的运行时会在逻辑处理器上调度goroutine来执行，每个逻辑处理器又分别绑定到单个的操作系统线程。像下图，如果一个Goroutine可以运行的时候，就会被放入到逻辑处理器的执行队列中，逻辑处理器有绑定到一个唯一的操作系统线程中。</p><p><img src="/images/qiniu/2019-08-25-20-03-52.png" alt="2019-08-25-20-03-52"></p><p>如果一个goroutine执行的是一个阻塞的系统调用，比如打开文件，那岂不是队列中的就绪态goroutine都的阻塞了？当出现这类调用时候，当前线程和当前的goroutine就会从逻辑处理器上分离，当前线程继续阻塞，等待刚刚的系统调用的放回。同时，逻辑处理器失去用来运行的线程。所以调度器就会创建一个新线程，并将其绑定到逻辑处理器上。当阻塞的系统完成调用并且返回，对应的goroutine会放回到本地运行队列，而之前的线程会保存好，一遍之后可以继续使用。如下图，线程A本来是绑定在P0的，后来有阻塞调用，就脱离出去了，然后线程B又绑定了P0。</p><p><img src="/images/qiniu/2019-08-25-20-21-14.png" alt="2019-08-25-20-21-14"></p><p>golang默认可以创建的线程数量为10000个线程，可以通过runtime/debug包的SetMaxThreads方法来更改。</p><!-- golang由于天生的支持高并发的应用，得到了很多大的基础项目的青睐。在golang的并发中最小的单元即为goroutine。今天来聊一下goroutine是怎么和chan配合的。## channel的分类channel分为非缓存chan和有缓存chan，  --><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>The C10K problem</p><p><a href="https://cloud.tencent.com/developer/article/1346210" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1346210</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;golang-并发基础（一）&quot;&gt;&lt;a href=&quot;#golang-并发基础（一）&quot; class=&quot;headerlink&quot; title=&quot;golang 并发基础（一）&quot;&gt;&lt;/a&gt;golang 并发基础（一）&lt;/h1&gt;&lt;p&gt;golang 在语言的语法和运行时方面内置了对并发的支持。在了解golang的并发之前，我们先看一下操作系统的两个概念：线程和进程。你应该知道，在系统中运行一个程序，其实就是启动了一个进程，而要运行起来，对外来说肯定是需要资源的，比如cpu，内存空间，文件句柄，线程等等..每个进程至少有一个线程，每个进程的初始线程被称为主线程。了解到这些，你大概可以类比一下，比如你创建一个项目，肯定要有main方法（主线程），你的项目中可能还有不同的业务逻辑，这个时候就可以让主进程创建多个线程去运行求结果。线程可以共享进程的空间。另外我们要知道，cpu的执行方式是轮询时间分片的，也就是可能这个线程有10ms的cpu执行时间，所以如果是单核cpu，就是每个线程执行一会，抢占式执行。并发(concurrency)不是并行(parallelism)。并行是在相同的时候让不同的代码都能在不同的处理器上执行，也就是同时做很多事情。并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。&lt;br&gt;
    
    </summary>
    
      <category term="并发" scheme="http://chenzhijun.me/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="golang" scheme="http://chenzhijun.me/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>过去一段时间遇到的一些问题</title>
    <link href="http://chenzhijun.me/2019/08/17/record-last/"/>
    <id>http://chenzhijun.me/2019/08/17/record-last/</id>
    <published>2019-08-17T09:16:25.000Z</published>
    <updated>2020-05-13T13:33:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随笔-过去一段时间遇到的一些问题"><a href="#随笔-过去一段时间遇到的一些问题" class="headerlink" title="随笔-过去一段时间遇到的一些问题"></a>随笔-过去一段时间遇到的一些问题</h1><a id="more"></a><p>Q: Ansible 远程执行无法找到命令的问题。</p><p>A: 实际上是bash / sh的问题，执行的时候使用<code>ansible all -i hosts -m shell -a &#39;PATH=&quot;/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/bin:/usr/bin&quot;;source /etc/profile;groupadd docker&#39;</code></p><p>Q：kubernetes 一个节点的ip被加入到集群中，使得节点ip变成了kube-ipvs0里面的子网</p><p>A: 创建了外部服务，但是外部服务的ip地址为node的一个节点ip，产生的后果为这个节点与其它节点直接无法ping通。</p><p>Q: Docker 使用非Root用户管理或者 Docker无权限</p><p>A: <a href="https://docs.docker.com/install/linux/linux-postinstall/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/linux-postinstall/</a></p><p><code>Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post http://%2Fvar%2Frun%2Fdocker.sock/v1.26/build?buildargs=%7B%7D&amp;buildbinds=null&amp;cachefrom=%5B%5D&amp;cgroupparent=&amp;cpuperiod=0&amp;cpuquota=0&amp;cpusetcpus=&amp;cpusetmems=&amp;cpushares=0&amp;dockerfile=Dockerfile&amp;labels=%7B%7D&amp;memory=0&amp;memswap=0&amp;networkmode=default&amp;pull=1&amp;rm=1&amp;shmsize=0&amp;t=harbor.uat.cmft.com%2Fcmft-library%2Fadms-app-0627%3A170&amp;ulimits=null: dial unix /var/run/docker.sock: connect: permission denied</code></p><p>Q: Docker 的远程仓库用户权限文件。</p><p>A: <code>$HOME/.dockercfg</code> 在用户根目录的<code>.dockercfg</code>目录。如果要查当前仓库登陆的用户<code>docker login hub.xxx.com</code></p><p>Q：kubernetes 直接运行一个pod</p><p>A: <code>kubectl run testconfig --image=harob -o yaml --dry-run</code></p><p>Q：kubernetes 获取某个资源的解释或者yaml的定义解释</p><p>A：<code>kubectl explain pods.spec</code></p><p>Q: git 使用代理</p><p>A: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://proxy.example.com:8888</span><br><span class="line"></span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line"></span><br><span class="line">git config --global --add remote.origin.proxy "socks5://127.0.0.1:18001"</span><br><span class="line"></span><br><span class="line">git config --unset-all</span><br></pre></td></tr></table></figure><p>Q：docker删除不需要的镜像。</p><p>A: <code>docker images|grep &#39;none&#39;|awk &#39;{print $3}&#39;|xargs -r docker rmi -f</code></p><p>Q：MySQL 集群无法重启</p><p>A: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;wsrep_provider_options&apos;;</span><br><span class="line">/data/mysql/grastate.dat 修改</span><br><span class="line">safe_to_bootstrap: 1</span><br></pre></td></tr></table></figure><p>Q: linux某个进程无响应</p><p>A: <a href="https://blog.csdn.net/jctian000/article/details/80695025" target="_blank" rel="noopener">https://blog.csdn.net/jctian000/article/details/80695025</a></p><p><code>/proc/进程号/fd</code></p><p><code>/proc/进程/stack</code></p><p>Q：Linux逻辑卷扩容</p><p>A:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vgextend vg00 /dev/vdc</span><br><span class="line">lvextend -L +20G /dev/vg00/home</span><br><span class="line">xfs_growfs /dev/vg00/home</span><br></pre></td></tr></table></figure><p>Q: curl timeout</p><p>A: <code>curl --connect-timeout 2 -m 5 100.66.7.2:25</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;随笔-过去一段时间遇到的一些问题&quot;&gt;&lt;a href=&quot;#随笔-过去一段时间遇到的一些问题&quot; class=&quot;headerlink&quot; title=&quot;随笔-过去一段时间遇到的一些问题&quot;&gt;&lt;/a&gt;随笔-过去一段时间遇到的一些问题&lt;/h1&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://chenzhijun.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://chenzhijun.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>jenkins-docker-plugin-error</title>
    <link href="http://chenzhijun.me/2019/07/24/jenkins-docker-plugin-error/"/>
    <id>http://chenzhijun.me/2019/07/24/jenkins-docker-plugin-error/</id>
    <published>2019-07-24T10:23:51.000Z</published>
    <updated>2020-05-13T13:33:03.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jenkins-Docker-模块无法切换Registry-credentials"><a href="#Jenkins-Docker-模块无法切换Registry-credentials" class="headerlink" title="Jenkins Docker 模块无法切换Registry credentials"></a>Jenkins Docker 模块无法切换Registry credentials</h1><p>问题产生，一次公司Jenkins迁移过程中，发现一个问题，dockers模块选择不同用户的 Registry credentials 但就是无法推送到私有仓库上去。</p><p><img src="/images/qiniu/2019-07-24-18-28-43.png" alt="2019-07-24-18-28-43"></p><p>像上图一样，选择了用户，deployop 或者其它，但是Jenkins push的时候就是报没有权限：</p><p><img src="/images/qiniu/2019-07-24-18-30-05.png" alt="2019-07-24-18-30-05"></p><p>就算我选的的是harbor的admin账号也没用。</p><p>后来想到jenkins的机器我是都手动执行过<code>docker login</code>的，不知道会不会有影响，于是手动去机器上docker build –&gt; docker push 发现结果一样。也是没有权限。然后用docker login harbor.xxx.com 查看当前用户却不是admin账户，这就有点奇怪了，我当时在jenkins模块docker中选的就是admin啊。为什么docker 还是用之前的权限较小的账户了？然后我在~/.docker/config.json 查看到确实有两个账户，这个可以说明其实Docker 模块的Registry credentials其实际是起到了作用的。应该是我们一开始使用了docker login 所以造成了有”默认账户”。jenkins应该就是使用了默认账户才导致这个问题的。</p><p><img src="/images/qiniu/2019-07-24-18-35-44.png" alt="2019-07-24-18-35-44"></p><p>解决的方式很简单，一个是删除<code>~/.docker</code>这个文件夹；一个是使用<code>docker logout harbor.xxx.com</code>就可以了。再用Jenkins构建的时候就可以看到该文件内容：</p><p><img src="/images/qiniu/2019-07-24-18-39-09.png" alt="2019-07-24-18-39-09"> </p><p>如果你是删除了<code>~/.docker</code>文件夹，然后重启docker，那么你再次构建的时候应该会看到<code>~/.docker</code>文件夹变空了。但是在用户目录多出一个<code>~/.dockercfg</code>文件。里面的内容和config.json一致。如果你是使用docker logout，那么就还是会在<code>~/.docker/config.json</code>文件中看到你每次选择的用户。</p><p><img src="/images/qiniu/2019-07-24-18-43-39.png" alt="2019-07-24-18-43-39"></p><blockquote><p>ps 如果想在jenkins启动的时候就指定其工作目录，可以这样设置<code>export JENKINS_HOME=/data/jenkins/.jenkins</code> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jenkins-Docker-模块无法切换Registry-credentials&quot;&gt;&lt;a href=&quot;#Jenkins-Docker-模块无法切换Registry-credentials&quot; class=&quot;headerlink&quot; title=&quot;Jenkins Do
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>golang 基础入门 - 数据类型</title>
    <link href="http://chenzhijun.me/2019/07/14/golang-type/"/>
    <id>http://chenzhijun.me/2019/07/14/golang-type/</id>
    <published>2019-07-14T15:21:30.000Z</published>
    <updated>2020-05-13T13:33:03.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="golang-基础入门-数据类型"><a href="#golang-基础入门-数据类型" class="headerlink" title="golang 基础入门 - 数据类型"></a>golang 基础入门 - 数据类型</h1><p>任何一门语句都会有它的基本关键字和数据类型。golang的数据类型大致分为三种：基本类型，引用类型，结构体。</p><p><img src="/images/qiniu/2019-07-14-23-35-07.png" alt="2019-07-14-23-35-07"></p><p>类型的一些细节可以参考：<a href="https://github.com/golang/go/wiki" target="_blank" rel="noopener">官网</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;golang-基础入门-数据类型&quot;&gt;&lt;a href=&quot;#golang-基础入门-数据类型&quot; class=&quot;headerlink&quot; title=&quot;golang 基础入门 - 数据类型&quot;&gt;&lt;/a&gt;golang 基础入门 - 数据类型&lt;/h1&gt;&lt;p&gt;任何一门语句都会有它
      
    
    </summary>
    
      <category term="Go" scheme="http://chenzhijun.me/categories/Go/"/>
    
    
      <category term="golang" scheme="http://chenzhijun.me/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang 基础入门</title>
    <link href="http://chenzhijun.me/2019/07/14/hello-golang/"/>
    <id>http://chenzhijun.me/2019/07/14/hello-golang/</id>
    <published>2019-07-14T04:55:21.000Z</published>
    <updated>2020-05-13T13:33:03.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-基础入门"><a href="#Golang-基础入门" class="headerlink" title="Golang 基础入门"></a>Golang 基础入门</h1><p>了解任何事物首先得了解一下它的历史。golang 在2007年就开始开发，在09年开源，并且在12年发布了第一个稳定版本GO 1。今年19年，go这些年的发展是很快的，目前的版本是go 1.12.7，目前go的开发节奏是半年发布一个版本。并且golang承诺，go的更新时兼容之前的版本的。</p><h2 id="Golang-安装"><a href="#Golang-安装" class="headerlink" title="Golang 安装"></a>Golang 安装</h2><p>在golang的官网<a href="https://golang.org/" target="_blank" rel="noopener">golang.org</a>下载最新版本的golang或者你需要的版本。接下来如果是windows的机器，那么只需要一路next就行了,之后在<code>c:\\go</code>文件夹下就可以了。如果是Linux系统，只需要将tar.gz包解压到自己工作的位置，然后将$GOLANG_PATH\bin加入到path就可以了。</p><a id="more"></a><h2 id="Hello-Go"><a href="#Hello-Go" class="headerlink" title="Hello Go"></a>Hello Go</h2><p>开始一门新语言的探险时，大家的第一个demo肯定是“Hello World”。我们也开始第一个”Hello Go”吧：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello,Go.."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的内容保存为一个<code>main.go</code>文件，然后使用<code>go run main.go</code>。你就可以看到输出了，超级简单。</p><p>不得不说是真的简洁。看到上面的代码，我们开始进行一下基本golang开发介绍。</p><h2 id="main包main方法"><a href="#main包main方法" class="headerlink" title="main包main方法"></a>main包main方法</h2><p>golang中定义一个包的关键字就是<code>package</code>，程序的入口始终都是<code>main</code>包中的<code>main()</code>方法，程序始终都是从这里开始。<br>不像Java中的lang包不需要导入，golang中除了一些关键字，其它的不管是内部包，还是外部包都需要通过关键字<code>import</code>进行导入。</p><h2 id="GOROOT，GOPATH"><a href="#GOROOT，GOPATH" class="headerlink" title="GOROOT，GOPATH"></a>GOROOT，GOPATH</h2><p>golang 中有个路径非常重要：GOROOT 和 GOPATH ; </p><p>GOROOT ： 其实就是golang的安装目录，当你用在控制台输入： <code>go env GOROOT</code>就能获取到值。</p><p>GOPATH ： 实际开发工作的目录。</p><p>GOROOT 就不多讲了，这里讲一下GOPATH；golang程序开发不像之前Java开发，Java开发，可能是项目名/src/路径-源码。而golang中，你的所有开发代码其实都是放在GOPATH下的，而且是在$GOPATH/src下。在GOPATH中定义了三个文件夹：<code>src</code>,<code>pkg</code>,<code>bin</code>。</p><ol><li>pkg 存放项目编译时期的中间文件，比如:<code>.a</code>文件；</li><li>bin 目录存放项目的可执行文件，如果你把这个路径放到path目录下，那么就可以直接在控制台执行这里目录下的可执行文件；</li><li>src 源码存放路径记住，开发中一定要将代码放到这个路径下；比如Java开发者可能就不适应，因为之前的Java是<code>项目名/src</code>的方式，现在golang是<code>src/项目名</code>;</li></ol><p>如果开发一个应用<code>myserver</code>,那么目录结构就是：<code>$GOPATH/src/myserver</code>; golang在编译的时候是会自动去找GOPATH下src目录的。这样你可以把所有相关联的项目放到一个GOPATH路径下，不同的项目之间可以隔开，也可把所有项目都放在一个GOPATH下，这样这个路径下的所有包，你都可以直接导入。当然你也可以照样像Java那样包路径结构，只是需要记住要将项目根路径指定为GOPATH，不然编译就会报错。</p><h2 id="golang的包"><a href="#golang的包" class="headerlink" title="golang的包"></a>golang的包</h2><p>你可能注意到了我们上面<code>hello go</code>的第二行 <code>import &quot;fmt&quot;</code>；这里的作用就是导入fmt包，这个包在哪里了？golang寻找import包的优先级为：GOROOT–&gt;GOPATH;如果找不到你也可以使用<code>go get</code>工具，它会帮你自动下载包;</p><p>项目开发中项目结构如下：</p><p><img src="/images/qiniu/2019-07-14-22-14-21.png" alt="2019-07-14-22-14-21"></p><p>我们看一个包导入的例子：</p><p><img src="/images/qiniu/2019-07-14-22-42-50.png" alt="2019-07-14-22-42-50"></p><p>我在项目中的handler下定一个了方法<code>Hello</code>，包名为<code>handler</code>;正常情况下，在main包中我们如果掉用它的话就是<code>handler.Hello()</code>;如下：</p><p><img src="/images/qiniu/2019-07-14-22-44-21.png" alt="2019-07-14-22-44-21"></p><p>可以看到，main 方法中出了一场，报的是找不到handler包。这个时候要看一下我们的GOPATH了，之前我们也说了golang是先从goroot再从gopath去寻找包的。goroot，一般大家也不会将源码放那里，我们现在看下GOPATH的目录：</p><p><img src="/images/qiniu/2019-07-14-22-46-46.png" alt="2019-07-14-22-46-46"></p><p>这下可以看到了吧。我们的项目路径是：<code>D:\workspace-paas\goinaction</code>;但是gopath的路径是<code>D:\Users\chenzj001\go</code></p><p>我们可以知道GOPATH下是没有我们的handler包的。这个时候的修改方式有两个：</p><ol><li>将项目移到gopath目录的src目录下；</li><li>将GOPATH设置为当前的工作目录；</li></ol><p>如果采用1的话那么恭喜你，问题解决。如果采用2,哈，那么恭喜你，你肯定是Java派golang开发者，同道中人啊。你可能会想，我不是将GOPATH指到当前项目根路径了么？怎么还是导入不了。唉~。其实就像前面说的，go寻找包的时候都是去src目录下找的。所以你需要在项目路径下再建立一个src目录，再将源码放进去，就能解决异常了，采用2，就相当于是你要用Java开发的包路径结构。这种其实是不推荐的，入乡随俗还是独树一帜看你选择了。我是觉得按照大家的约定会比较好。</p><p>我们采用第一种方式，你看下图：</p><p><img src="/images/qiniu/2019-07-14-22-59-40.png" alt="2019-07-14-22-59-40"></p><p>你可以看到上面的gopath。</p><blockquote><p>ps: 其实你是可以同时设置多个GOPATH的哦，可以自己动手尝试一下。</p></blockquote><h2 id="GO-自带的工具"><a href="#GO-自带的工具" class="headerlink" title="GO 自带的工具"></a>GO 自带的工具</h2><p>GO 自带了一些常用工具，使用<code>go --help</code>就能看到。这里介绍常用的几个：</p><ol><li><code>go build</code>,编译包</li><li><code>go run</code>,编译运行</li><li><code>go fmt</code>,golang内置的将代码格式化</li><li><code>go doc</code>,golang的文档</li><li><code>go test</code>,golang测试工具</li><li><code>go get</code>,下载导入外部包</li></ol><p>go 也可以编译成其它平台的可执行文件，比如window下编译成Linux下的执行文件<a href="http://chenzhijun.me/2019/03/31/windows-compile-golang-to-linux-running-script/">golang编译成Linux环境下的二进制文件</a>。</p><p>go 的这些工具还是挺有用的，没事可以多用用。</p><p>这篇文章介绍了下go的发展史，也写下了<code>hello go</code>之后介绍了gopath，goroot，以及go自带的工具。其实golang其实是面向程序员友好的，对比Java动辄就是几十行代码，golang确实很简洁。不过对比Java来说，golang的生态其实感觉并没有Java那么的完善，另一方面，golang的包管理，我到现在还是有点。。还有一个就是在国内访问golang官网需要科学上网。这有点像什么了，我要推广给大家用，但是大家用起来又是各种阻碍，在已有的产品能实现需求的产品上，如果新产品不能提供很好的体验，其实要退光是有困难的。另一方面，golang其实面向的最多的感觉还是C/C++来转型。一门语言其实有它的优势，也肯定有它的不足。适合自己的业务场景，个人发展路径，取舍在于自己，我从一开始其实挺不喜欢golang的，但最近学会不排斥的心态去了解之后，感觉是真的爽。个人观点，不喜勿喷。一千个观众有一千个哈姆雷特。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Golang-基础入门&quot;&gt;&lt;a href=&quot;#Golang-基础入门&quot; class=&quot;headerlink&quot; title=&quot;Golang 基础入门&quot;&gt;&lt;/a&gt;Golang 基础入门&lt;/h1&gt;&lt;p&gt;了解任何事物首先得了解一下它的历史。golang 在2007年就开始开发，在09年开源，并且在12年发布了第一个稳定版本GO 1。今年19年，go这些年的发展是很快的，目前的版本是go 1.12.7，目前go的开发节奏是半年发布一个版本。并且golang承诺，go的更新时兼容之前的版本的。&lt;/p&gt;
&lt;h2 id=&quot;Golang-安装&quot;&gt;&lt;a href=&quot;#Golang-安装&quot; class=&quot;headerlink&quot; title=&quot;Golang 安装&quot;&gt;&lt;/a&gt;Golang 安装&lt;/h2&gt;&lt;p&gt;在golang的官网&lt;a href=&quot;https://golang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;golang.org&lt;/a&gt;下载最新版本的golang或者你需要的版本。接下来如果是windows的机器，那么只需要一路next就行了,之后在&lt;code&gt;c:\\go&lt;/code&gt;文件夹下就可以了。如果是Linux系统，只需要将tar.gz包解压到自己工作的位置，然后将$GOLANG_PATH\bin加入到path就可以了。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://chenzhijun.me/categories/Go/"/>
    
    
      <category term="golang" scheme="http://chenzhijun.me/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>PaaS 平台应当具备的能力</title>
    <link href="http://chenzhijun.me/2019/07/06/the-ability-of-a-paas-platform/"/>
    <id>http://chenzhijun.me/2019/07/06/the-ability-of-a-paas-platform/</id>
    <published>2019-07-06T05:23:12.000Z</published>
    <updated>2020-05-13T13:33:03.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PaaS-平台应当具备的能力"><a href="#PaaS-平台应当具备的能力" class="headerlink" title="PaaS 平台应当具备的能力"></a>PaaS 平台应当具备的能力</h1><p>一个完善的paas平台应该具备的能力:</p><p><img src="/images/qiniu/2019-07-06-13-31-12.png" alt="2019-07-06-13-31-12"></p><p>代码管理中有gitlab，github，gitee. etc…</p><p>配置管理中：开发，测试，生产一致性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PaaS-平台应当具备的能力&quot;&gt;&lt;a href=&quot;#PaaS-平台应当具备的能力&quot; class=&quot;headerlink&quot; title=&quot;PaaS 平台应当具备的能力&quot;&gt;&lt;/a&gt;PaaS 平台应当具备的能力&lt;/h1&gt;&lt;p&gt;一个完善的paas平台应该具备的能力:&lt;/p
      
    
    </summary>
    
      <category term="Paas" scheme="http://chenzhijun.me/categories/Paas/"/>
    
    
      <category term="PaaS" scheme="http://chenzhijun.me/tags/PaaS/"/>
    
  </entry>
  
  <entry>
    <title>Java 类转 Json 时属性名使用下划线</title>
    <link href="http://chenzhijun.me/2019/07/06/java-json-generate-with-underline/"/>
    <id>http://chenzhijun.me/2019/07/06/java-json-generate-with-underline/</id>
    <published>2019-07-05T16:26:28.000Z</published>
    <updated>2020-05-13T13:33:03.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-类转-Json-时属性名使用下划线"><a href="#Java-类转-Json-时属性名使用下划线" class="headerlink" title="Java 类转 Json 时属性名使用下划线"></a>Java 类转 Json 时属性名使用下划线</h1><p>很多时候和其它系统对接的时候，不太喜欢用驼峰的方式，毕竟如果是给前端的api，写个驼峰总感觉有点怪异，总喜欢将属性使用下划线。也就是一个<code>bookName</code>,给前端的时候是：<code>book_name</code>，当然如果是后台系统，还是使用驼峰啊。</p><h2 id="Java-统一-json-为下划线"><a href="#Java-统一-json-为下划线" class="headerlink" title="Java 统一 json 为下划线"></a>Java 统一 json 为下划线</h2><p>在 Java 中有两种方式可以实现这种方式，一种是全局的，一种是局部。<br><a id="more"></a></p><h3 id="全局修改属性的json名为下划线格式"><a href="#全局修改属性的json名为下划线格式" class="headerlink" title="全局修改属性的json名为下划线格式"></a>全局修改属性的json名为下划线格式</h3><p>如果需要全局的修改，那么只需要在类上面使用<code>@JsonNaming(PropertyNamingStrategy.SnakeCaseStrategy.class)</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.enumjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.PropertyNamingStrategy;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonNaming;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonNaming</span>(PropertyNamingStrategy.SnakeCaseStrategy<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Instance</span> </span>&#123;</span><br><span class="line">    Object state;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instance</span><span class="params">(Object state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state=state;</span><br><span class="line">        <span class="keyword">this</span>.bookName=<span class="string">"《json转换》"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(Object state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookName</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的json为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"state"</span>: <span class="string">"Success"</span>,</span><br><span class="line">    <span class="attr">"book_name"</span>: <span class="string">"《json转换》"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部修改属性的json名为下划线格式"><a href="#局部修改属性的json名为下划线格式" class="headerlink" title="局部修改属性的json名为下划线格式"></a>局部修改属性的json名为下划线格式</h3><p>局部的方式就是使用<code>@JsonProperty(value = &quot;book_name&quot;)</code>这个作用在属性上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenzhijun.enumjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instance</span> </span>&#123;</span><br><span class="line">    String state;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span>(value = <span class="string">"book_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instance</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.bookName = <span class="string">"《json转换》"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookName</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jsonTest</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    Instance instance = <span class="keyword">new</span> Instance(<span class="string">"success"</span>);</span><br><span class="line">    System.out.println(objectMapper.writeValueAsString(instance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-类转-Json-时属性名使用下划线&quot;&gt;&lt;a href=&quot;#Java-类转-Json-时属性名使用下划线&quot; class=&quot;headerlink&quot; title=&quot;Java 类转 Json 时属性名使用下划线&quot;&gt;&lt;/a&gt;Java 类转 Json 时属性名使用下划线&lt;/h1&gt;&lt;p&gt;很多时候和其它系统对接的时候，不太喜欢用驼峰的方式，毕竟如果是给前端的api，写个驼峰总感觉有点怪异，总喜欢将属性使用下划线。也就是一个&lt;code&gt;bookName&lt;/code&gt;,给前端的时候是：&lt;code&gt;book_name&lt;/code&gt;，当然如果是后台系统，还是使用驼峰啊。&lt;/p&gt;
&lt;h2 id=&quot;Java-统一-json-为下划线&quot;&gt;&lt;a href=&quot;#Java-统一-json-为下划线&quot; class=&quot;headerlink&quot; title=&quot;Java 统一 json 为下划线&quot;&gt;&lt;/a&gt;Java 统一 json 为下划线&lt;/h2&gt;&lt;p&gt;在 Java 中有两种方式可以实现这种方式，一种是全局的，一种是局部。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://chenzhijun.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://chenzhijun.me/tags/Java/"/>
    
      <category term="Json" scheme="http://chenzhijun.me/tags/Json/"/>
    
  </entry>
  
</feed>
